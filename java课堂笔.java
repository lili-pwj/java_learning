第一章 
/*
1.相关DOS命令：
(1)DOS命令在哪里编写 ---》cmd
(2)exit  退出
	 cls   清除
	 DOS窗口中的内容如何复制：选中---》鼠标右键---》已经在剪切板了
	 dir-->列出当前目录的所有的文件
	 cd 命令 ---》 *cd命令表示 change directory 改变目录 cd 在同一个盘下 可以自由cd进出，但不可以直接跨其他盘的其他具体位置  比如在d盘，不能直接 cd C:\Users\24537\Desktop
	              *如何用：  cd 目录的路径 
	             路径---》1.绝对路径 2.相对路径 
	             1.绝对路径：表示该路径从某个磁盘的盘符下作为出发点的路径
	             2.相对路径：表示该路径从当前所在的路径下作为出发点的路径
	             cd C:\Users\24537\Desktop  这样就是一个绝对路径 
	             cd C:\Users\24537\Desktop  == cd desktop
	-cd .. 表示回到上级目录 
	c: 回车  --》去到 C盘
	d: 回车  --》去到 D盘
	类推....

2.保证文件的类型是.java

3.第一代语言  ：机器语言---》主要编写二进制码，直接比那些10010101010
	第二代语言：低级语言---》	主要以汇编语言为代表 
	第三代语言：高级语言  

4.java包括三大块：
		-JavaSE（Java标准版）
		-JavaEE（Java企业版）
		-JavaME（Java微型版）

5.Java语言特性  （开源、免费、纯面向对象、跨平台）
1)java语言底层是C++实现的
2)Java纯面向对象的，更符合人的思维模式，更容易理解
3)可移植性（跨平台）： 可以在Windos 可以在Linus操作系统上运行 （移植的是.class 只要安装了jdk）


6.Java的加载和执行
 包括两个重要的过程 1.编译 2.执行
6.1	-编译(用javac)用javac检查Java源程序是否符合Java语法)符合，就能正常生成字节码文件（xxx.class)
				1.创建一个.java （源文件） 要符合Java语法
				2.需要使用JDK当中自带的javac.exe命令进行Java程序的编译
				在哪里用javac？   --->在DOS命令窗口使用
				javac是java的编译器工具
				3.一个java源文件可以生成多个.class文件
			java文件删除后不会影响.class  但是一般java不要删除 
		4.编译结束之后，可以拷贝.class文件到其他操作系统中（跨平台）
		A.class A称为一个类（名）  B.class B也是一个类（名）
6.2 运行阶段 (主要用到JDK java.exe)
			-JDK包括:
				1.javac  
				2.java.exe ---》负责运行 在DOS窗口使用（一定要在含有.class的目录下）
					如果硬盘上有一个A.class ，就输入： java A
					如果硬盘上有一个B.class ，就输入： java B
					错误写法： java A.class 
			-运行阶段的过程
				1.打开DOS --》输入java A ---》java.exe命令会启动Java虚拟机（JVM)---》JVM启动类加载器ClassLoader
				2.ClassLoader搜索A.class文件，找到后---》将该字节码文件装载到JVM当中
				3.JVM将A.class字节码文件解释成二进制10101010这样的数据
				4.操作系统执行二进制和底层硬件平带运行交互
				
7.第一个java程序
	1.条件：
			安装了文本编辑文件
	2.JDK JRE  JVM 
	 		JDK包括 JRE包括 JVM 
	3.JDK目录介绍
		JDK/bin：该目录放了许多命令，例如 javac.exe和java.exe
		javac 负责编译  
		java.exe 运行
	4.将.java  通过javac工具进行编译
			（没有添加环境变量前出现错误的原因结果探究：
				windows 操作系统首先从当前目录搜索，
				搜索不到就会从环境变量path指定的路径当，路径之间用“ ；”（英文分号）隔开 中搜索
				都搜索不到的话就报错）
			1.javac命令怎么用 :  javac xxxx.java  (**一定要加绝对目录或者相对目录位置下运行 无法通过设置环境变量 而eclipse可以)
					1.绝对路径方法：打开DOS 打开.java 所在文件夹 把 .java拖进去DOS ----》当前文件夹就会生成.class ?
					或： 相对路径（需要切换到当前目录）： javac  HelloWorld.java
			2.运行java程序
				-需要java.exe
				-使用方式 ：java 类名
						前提：硬盘上有HellowWorld，那么类名就是：HelloWorld 
						 一定注意：java命令后面跟的不是文件路径，是一个类名
				     -首先把DOS目录切换到HelloWorld.class目录下 
			3.关于java源程序当中的注释
					.java 上的注释不会出现在.class中
					建议多写注释
					注释：
						1.单行注释  //
						2.多行注释 	/*  xxxxxxxxx  */
						3.javadoc注释 ---》将来会被javadoc.exe解析，生成帮助文档。 类似于说明书  
						/** 
						* javadoc注释
						*	javadoc注释
						*	javadoc注释
								
						" “” "  里面是全角的 不能是半角
						
						
			4.对HelloWorld 程序进行解释：
				需要记忆：
					*public 
					*class
					*static
					*void
					*System.out.println(""); 
					*类体 
					*方法体
					*类体中不能编写java语句，除声明变量外
					主方法是程序入口
		
			5. class 和 public class 的区别
			一个java源文件可以定义多个class
				一个java源文件当中 public class 不是必须的 
				一个class会对应生成一个xxx.class 文件
				一个java源文件当中定义公开的类的话，public class 只能有一个，
				并且该类名必须要和java源文件名称一致
				每一个class中都可以编写main方法，都可以设定程序入口
					例如执行B.class (源文件众多class 中的一个，经过javac 编译出来的 B.class)
					 就是： java B  
					想执行 .class 的main方法 ，Java X
				但是要注意：当在命令窗口执行java B 的时候，要求B.class中类体下面必须要有主程序入口

--------------------------------------------------------------------------------------	
第二章：
一、标识符
/*
关于java语言的标识符
	1.什么是标识符？
	-在java源程序中，有权利命名的单词都是标识符。
	-在编辑器中，以下是标识符
		*类名 （首字母大写，后面每个单词首字母大写）
		*接口名（首字母大写，后面每个单词首字母大写）
		*方法名（首字母小写，后面每个单词首字母大写）
		*变量名（首字母小写，后面每个单词首字母大写）
		*常量名（大写）
		....
	2.标识符的命名规则
		*一个合法的标识符只能由数字、字母、下划线_、美元符号$组成
		*不能数字开头
		*严格区分大小写
		*关键字不能做标识符
		*理论上无长度限制

	3.标识符的命名规范（只是一种规范）
  	*见名知意
  	*遵守驼峰命名 ：SystemService
  	*类名、接口名：首字母大写，后面每个单词首字母大写
  	*变量名、方法名：首字母小写，后面每个单词首字母大写
  	*常量名：全部大写
*/  	
----------------------------------------------------------------------------------
         	
 二、关键字

关于java语言的关键字
	关键字在java语言当中全部小写
	关键字  蓝色
	常见的关键字：
	*public
	*class
	*static
	*void
	*if
	*for
	*while
	*do
	*default
	*byte
	*short
	*int
	*long
	*float
	*double
	*boolean
	*char
	*private
	*protected
	*switch
	*true
	*false
	*throw
	*try
	*catch
 		
--------------------------------------------------------------------------------------
三、字面值
 /*
 关于字面值
 	*字面值:即字表面的值，=数据
 		- 10
 		- 100
 		-'a'
 		-"abc"
 		-true
 		-false
 		都是字面值
 		是java源程序的组成部分之一
 		数据有类型
 			-10、100 没有小数点，属于整数型字面值
 			-3.14 属于浮点型字面值
 			-"abc" 字符串型字面值
 			-'A'，'人'   ，字符型
 			-true，false 布尔型字面值
 			*需要注意的是：java语言当中的所有的字符串型字面值必须要用"" 
 			*java当中的字符型必须要用'' 
 			
 		*/
 --------------------------------------------------------------------------------
四、变量

/*
关于java中的变量
	1.什么是变量？
		变量本质上是内存中有一块空间，这块空间有 1.数据类型，2.名字 3. 有字面值
		变量是内存中存储数据的最基本的单元
	2.数据类型的作用？
		*不同的数据类型有不同的类型，不同的数据类型底层会分配不同大小的空间
		*数据类型是指导程序在运行过程阶段应该分配多大的内存空间
	3.变量的要求：变量中存储的具体的“数据”必须和变量的数据类型一致，否则报错
	4.声明/定义变量的语法格式：
		   * 数据格式 变量名
		   * 变量名  合法的标识符就行:首字母小写，后面每个单词首字母大写
	5.变量声明之后的赋值
		语法格式：  变量名 = 字面值 ;
		要求：字面值的数据类型必须和变量的数据类型一致
		= 等号是一个运算符，叫赋值运算符，赋值运算符先运算等号右边的表达式，
		执行结束后的结果赋值给左边的变量。
		 int a = 10 ;
	6.变量赋值之后，可以重新赋值，变量的值可变化
	
	7.对变量访问的两种方式：
		1.读取变量保存的具体数据 get/读取
		2.修改变量保存的具体数据 set/设置
		
	8.变量在一行上可以声明多个
	 int a,b,c;
	9.变量必须声明，再赋值，才能访问?
	 int i ; 程序执行到这里，内存空间并没有开辟，变量i 并没有赋值
	 	*/
	 	 	
	 	/*
  java 语言当中的变量
		1.方法体当中的java代码，是遵守自上而下，
		第一行的代码没结束，下一行的代码就不会开始	
		2.在同一个“作用域”当中，变量名不能重名，可以重新赋值
*/

/*
		关于java的变量
			变量的作用域
				1.什么是作用域？
					变量的作用域，就是描述变量的有效范围，
					出了这个范围，变量就无法访问
				2.变量的作用域只要记住的一句话
					出了大括号就不认识了。
*/

/*
		关于变量的分类
			根据变量声明的位置来分类：
			 	分为1.局部变量：在方法体内声明的变量
			 			2.成员变量：在方法体外【类体之内】声明的变量
		在同一个作用域中，变量名不可以重名 
		在不同的作用域中，变量名可以重名
			 			
*/

------------------------------------------------------------------------------------
第三章： 
一、数据类型
/*
  关于java中的数据类型
  		1.数据类型的作用是什么？
  				程序当中有许多数据，每个数据都是有相关类型的， 不同数据的数据占用空间
  				大小不同，数据类型的作用是指导JVM在运行程序的时候，给该数据分配多大的内存空间
  		2.java中的类型包括两种：
  			*基本数据类型
  			*引用数据类型
  					1.类，2.接口，3.数组 ....
  		
  		3.基本数据类型:
					包括4大类，8小种
						第一类：整数型
							byte，short，int，long
						第二类：浮点型
							float，double
						第三类：布尔型
							boolean
						第四类：字符型  
						  char	
			4.字符串"abc"不属于基本数据类型，属于引用数据类型
			 *字符串使用"":"abc"
			 *字符使用''：'a'
			 
			5.八种数据类型各自占有空间大小是多少？
					基本数据类型       占用空间[字节]
				----------------------------------------
				byte                1
			 	short								2
			 	int									4
			 	long								8
				float								4
				double              8
				boolean							1
				char                2
				
				基本数据类型       取值范围
				----------------------------------------
				byte                -128-127
			 	short								-32768-32767
			 	int									-2147483648-2147483647
			 	long								
				float								
				double              
				boolean							true，false
				char                0~65535 （没有负数）
				
				char 和short 所表示的种类个数都是一样的，因为都是2个字节
				
		 6.计算机在任何情况下只能识别二进制
		 	例如：只认识1001001010110......
		 7.什么是二进制
		 		*数据的一种表示形式。十进制表示满十进一原则，二进制，表示满二进一
		 		例如十进制
		 		 0 1 2 3  4 5 6 7 8 9 10 11 
		 		例如 二进制
		 		0 1 10 11 100 101 110 111 1000 1001 1011 1111
		 		0 1 2   3  4  5    6  7     8    9  10    11
		 		
		8.字节（byte）：
	   1 Byte = 8 bit 【一个字节= 8个比特位 比特位就是 0 或 1 】一个比特位，表示一个二进制位
	   1 Kb = 1024 byte
	   1 Mb = 1024 Kb
	   1 Gb = 1024 Mb
	   1 Tb = 1024 Gb
	   
	   1 Tb = 1024*1024*1024*1024*8  （可以存储..个0/1）
	  
	  9.整数型当中的byte 占用一个字节，所以byte类型的数据占用8个比特位
	  所以，byte类型的取值范围？(-128-127 -> 十进制）
	  		*byte 可以表示256不同的二进制 ---》对应-128-127 
	  		*java的数字类型，数字是有正负，
	  		*符号位：在所有二进制位的最左边，0：+  1：-
	  		*byte类型最大值：0111 1111 = [0000 0000 0000 1000 0000 (二进制）- 1 ] 
	  byte 的最大值： 2^7-1 结果是：127
	  byte 的最小值： -128（和原码，补码，反码有关）
	  
	  10.二进制和十进制之间的转换规则：
	  	*二进制转换成十进制： 例如 1010 = 2^1+2^3 = 9 
	  	*十进制转换成二进制： 
	  11.short 短整型 2个字节，18个比特位，取值范围：-2^15~2^15-1 
	  12.int 整型 4个字节 ，32个比特位，取值范围 -2^31~2^31-1
	  13.char (用字符编码  （现实世界当中的文字与计算机二进制之间的对照表）
	  	'a' -->97
	 	  'b' -->98
	  	'A' -->65
	 	  '0'	-->48
	  	按照ASCII编码
			'a' --(解码）-->01100001（97）
			01100001（97） --（编码）--->'a'			
		 
		支持简体中文的方式：GB2312 <GBK < GB18030 (容量大小)
		*后来出现了一种编码方式统一了全球所有的文字
		java采用unicode编码方式，所以标识符可以写中文
		*实际开发中，一般使用UTF-8比较多

/*   
			关于八种数据类型的默认值
					数据类型								默认值
			    ------------------------------
					byte short int long     0 
					float double         	  0.0
						boolean 							false
					char 										\u0000
					默认值一切向0看齐
				
*/
----------------------------------------------------------------------------------
/*
			关于java语言当中的char类型
			转义字符 ：\
				*转义字符出现在特殊字符之前，可以把特殊字符转义成普通字符 如 ' " 之前
				\t 制表符
				\n 换行
				\\反斜杠
				\' 单引号
				\" 双引号
				
*/
/*
			关于java语言当中的整数型
			数据类型		占用空间大小			默认值				取值范围
			-----------------------------------------------------
			byte 				1									0						[-128-127]
			short				2									0						[-32768~32767]
			int					4									0						[-2147483648~2147483647]
			long				8									0L
			
	1.java语言当中的"整数型字面值"被默认当作int类型来处理，要让这个"整数字面值"被当作long类型来处理
		的话，需要在字面值后面加l/L  建议大写
	2.java语言当中的整数型字面值有三种表示方式
	
			十进制：是一种默认缺省的方式 10 就是10  9 就是9 而不是09 010 前面不用添加其他来表明他是十进制
			八进制：在编写八进制整数型字面值的时候需要以0开始 比如 010= 8^1=8
			十六进制：在编写十六进制整数型字面值的时候，以0x开始，比如 0x10 = 16^1=16
			

*/
	public class DataTypeTest05{
	public static void main (String []args){
	long x =100L;//100L是long 不存在类型转换  
	//int y = x ;//编译错误，因为 100L占用了8个字节，而 int 只有4个字节 不配对 
	//大容量不可以直接赋给小容量
	//大容量---》小容量 需要强制类型转换符
	//强制类型转换符需要加"强制类型转换符"
	//加上强制类型转换符之后编译通过了，但是运行阶段可能损失精度，损失精度可能导致结果偏差很大
	int y = (int)x;
	System.out.println(y);
	/*强制转换原理：
原始数据： 00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100100
强制转换：00000000 00000000 00000000 01100100 （即把前面多余的4个字节（long8个字节 int4个）删了）
		
		
	*/
		long k = 2147483648L;
		int e = (int)k ;
		// 2147483648 ---> 00000000 00000000 00000000 00000000 10000000 00000000 00000000 00000000
	//转换之后 ---》 10000000 00000000 00000000 00000000  //目前存储在计算机内部，所以是一个补码形式
	   //把上面的补码转换成原码就是最终的结果：【-2147483648】
	
	
		System.out.println(e);// 损失精度严重 结果是负数
		int f = 50;
		byte b = (byte)f;//-128~127
	//因为 50 是int  和byte  不是同样的类型
	//原始             32 16  8  4  2 1
								//    1 	1 0	 0 1 0  
			// 00000000 00000000	00000000 00110010	
			// 转换后：  00000000 00110010
			System.out.println(b);
		// byte b = 50 ;  
		//分析 虽然字面值的默认类型是int型，但是 通过直接赋值，只要字面数值没有超过声明的
		// 的类型，那么就可以允许，而如果首先声明了一个变量，再直接赋值给其他不同类型的变量，会出现错误
		// 要进行强制转换  ，例如上面的 long 
		
		byte r = (byte)128 ;
		System.out.println(r);//结果是-128 
		//分析：128
    //128--》 00000000 00000000 00000000 10000000  128 
    //  	转换到byte，变成1个字节 --> 10000000 （补码） 
    //把 10000000 （补码）---》反码 ： ---》符号位不变 其他取反
    //---》10000000 =-128 
    
    /*
   原码 	     正（最左是0）       负（最左是1） 	
              --------------     -------------------									
	反码     		   不变            原码符号位不变，其他取反
	补码     	     不变						 反码+1    
	  
	  */
   byte m = (byte)198;
   System.out.println(m);
   //             128 64 32 16 8 4 2 1 
		//             1   1          1 1 0 
		//         00000000 00000000  00000000    11000110
		//转换成byte ：  1100 0110  （补码）---》 1100 0101（反码）
		///---》取反： 10111010  -58
}
}
---------------------------------------------------------------------------
/* 

		关于浮点型数据类型：
			float 单精度 【4个字节】
			double 双精度 【8个字节】 
			 double 的精度太低 不适合作财务软件
			 	java.math.BigDecimal 
			 	java程序员是基于一套由sun提供的庞大的类库 进行开发，所以要清楚java的SE类库在哪，
			 	要知道java的SE类库的源码在哪
			 		SE类库字节码  rt.jar
			 		SE类库源码： src.zip
			 	例如 String.java String.class  我们的（String[]args）中的string使用的就是 String.class

		在java语言中，所有的浮点型字面值，默认当作double来处理
		要想变成float类型来处理，需要在字面值后面加f/F  3.14F 3.14f    
	
	注意 double 和 float 在计算机内部二进制存储的时候都是近似值	。
	在现实世界中有些数字是无限循环的 例如1/3 0.333333333
*/


public class DataTypeTest06{
	public static void main (String[]args){
		//3.0就是doulbe类型
		double d = 3.0; 
		System.out.println(d);
		float f = 5.1; //编译会出现错误 因为损失了精度
		// f 是float 类型 变量 大容量转小容量需要加强制类型转换符   
		//解决：  1) float f = 5.1f ; 2）float f = (float)5.1;
		//第一种是自动转换机制 第二种是强制
		
		
	}
}
---------------------------------------------------------------------------------
/* 
		关于布尔型类型
			boolean
		
		在java语言当中 boolean 只有两个值 true 和 false 没有其他值
		不像c语言当中，0 和 1 可以表示假和真
		
		在底层储存的是偶， boolean 类型占用1个字节，因为实际存储的时候
	  false 底层是0 
		true 是1 
		
		布尔型类型在实际开发当中非常重要 经常使用在逻辑运算和条件控制语句当中。
		
		
*/
/*
		关于基本数据类型之间的互换：
			*规则：背！
			1.八种基本数据类型当中，除布尔类型之外， 其余7种之间都可以互相转换
			2.小容量----》大容量，称为自动类型转换
					byte < shot < int <long <float <doule
					char 
					*注意：任何浮点类型不管占用多少字节，都比整数型容量大
									char 和short 可表示的种类数量相同
									但是char 可以表示更大的整数字面数值
									char b = 97 
			3.大容量----》小容量  
					强制类型转换 ，需要加强制类型转换符 （xxx），程序才可以编译通过，但可能会损失精度
					
			4.当整数字面值没有超过byte short char 的取值范围，可以直接赋值
			
			5.byte，short char 混合运算时，各自先转换成int 类型再做运算
			
			6.多种数据类型混合运算时，会先转换成大容量最大的那种类型再做运算
例题  
int f = 10 /3 ; // = 3 
double f = 10/3; //=3.0
double f = 10.0/3;//==3.3333333   先把3 --3.0   double/double =double 
byte h =(byte)(int)g/3;//javac 只进行编译 检查语法，不运算 所以  
(byte)(int)g/3 --- （int）g --》整----》 byte----》byte/3----》int型 所以 int 和 byte 不一样 所以报错
解决方法：byte h = （byte）(int)(g/3) ;

byte h = (byte)g/3;
short i =10 ;
byte j = 5 ;
byte k = i + j ;  //错误 因为 i+j 是语法，short byte 在运算时 先转换成 int  i+j是int 所以错误
byte k = 15 ；正确，可以编译  表示直接把15赋给 byte 没超范围 
byte k = （short）(i+j); 可以
int k = i+j ； 可以
	char c = 'a';  或 char c = 97 ；
	System.out.println(c); // 输出都为 a 
	System.out.println((byte)c);//输出为97
	char c = 'a'
	int i = c + 100 ; //c先转换成int   
	System.out.println(i); //输出为 197 
	
	
	
------------------------------------------------------------------------------------------
*/
public class DataTypeTest08{
	public static void main  (String[]args){
	
		long d = 1000 ;
//		int e = d ;//大容量转小容量要先强制准换 而且转换后还可能损失精度  而小容量转大容量 则不用
		System.out.println(d);
		
	}
}









8.第一章总结
	1.搭建java开发环境
	2.独立编写HelloWorld，编译并运行
	3.掌握环境变量path的原理以及如何配置
	4.掌握环境变量classpath的原理以及如何配置
	5.java的注释
	6.public class 和class 的区别
	7.理解java的加载和执行
			

-------------------------------------------------------------------------------
四、运算符
/*
1.算术运算符 
2.关系运算符
3.逻辑运算符
4.赋值类运算符
5.字符串连接运算符
6.三元运算符	
*/

/*
1.算术运算符
		关于java变成中运算符之：算术运算符
			+，-，*，/，%，++，--
			
			注意：运算符之间有优先级，加括号可以先运算，加括号优先级得到提高
			
				
			++ -- 可以出现在变量前后， 只要++ -- 运算符结束，该变量一定自加（减）1
			// ++出现在变量后，在有赋值语句当中，先进行赋值，再自加 a = b++ 
			// ++出现在变量前，在有赋值语句当中，先进行自加，再赋值 a = ++b 
			
			-----------------------------------------------------------------------
			

2.逻辑运算符
		
			逻辑运算符：
			& 		逻辑与   （两边的算子都是true，结果是真）
			|			逻辑或	（两边的算子有一个是真，结果是真）
			！		逻辑非		（取反， ！false =真， ！true=假） 这是一个单目运算符
			^			逻辑异或	（两边的算子只要不一样，结果就是true ）
			
			&&		短路与		短路与
			||		短路或		短路或

			
	1、逻辑运算符要求两边的算子都是布尔类型，并且逻辑运算符最终的运算结果也是一个布尔类型
	2.短路与 和逻辑与 两者最终的运算结果是相同的，只不过，短路与存在短路现象
	3.短路或 和逻辑或 两者最终的运算结果是相同的，只不过，短路或存在短路现象
	4.什么情况下发生短路现象？ 
	5.什么时候选择逻辑与运算符，和短路与运算符
		
3.关系运算符
		关系运算符  *关系运算符最后的结果一定是布尔型 ：true / false
				>   大于
				>=  大于等于
				< 	小于
				<=	小于等于
				==  等于
				！= 不等于
				= 赋值运算符
				== 关系运算符
		关系运算符的运算原理：
		int a =10
		int b = 10
		a>b 比较的时候，是比较a中保存的10这个值，和b保存中的10这个值之间的大小


4.赋值运算符
	关于java中的赋值类运算符
				复制类运算符包括：
				1. 基本赋值运算符
				 = 
				 
				2.扩展的赋值运算符
					+=
					-=
					*=
					/=
					%=
			1.赋值类的运算符优先级：先执行等号右边的表达式，将执行结果赋值给左边的变量
			2.注意以下代码
				byte i = 10 ;
				i +=5 ; 等同于 i = （byte）(i+5);
				int k = 10 ;
				k += 5 ; 等同于 k = (int)(k+5);
				
				long x = 10L
				int y = 20 ;
				y += x ; 等同于 y=(int)(y+x);
				
			3.扩展类的赋值运算符不改变运算结果类型，假设最初这个变量类型还是byte，
			最后变量的类型还是byte

*/

/*
5.字符串连接符

 关于java中的 + 运算符
		  1.+ 运算符在java中语言中的作用
		  		加法运算
		  		字符串的连接运算
		  2.当"+" 运算符两边的数据都是数字，一定时进行加法运算，
		  3.当“+” 运算符两边只要有一个是字符串，则一定进行字符串连接运算，
		  并且，连接运算之后的结果还是一个字符串类型
		  
		  数字+"avc" ---> 字符串 【字符串连接】
		  
		
		  4.在没有添加小括号的情况下 ，遵循 自左 向右 计算 （优先级）
*/
/*

6.三元运算符

		java的三元/三目/条件运算符
			1.语法规则：
				布尔表达式?表达式1：表达式2
				如果布尔表达式的结果为true ，就选择 表达式1 作为整个表达式的执行结果
				如果布尔表达式的结果为false,就选择 表达式2作为整个表达式的执行结果
			2.三元运算符的执行原理
			
		
		
*/

/*
	键盘输入
		
		第一步：java.util.Scanner s = new java.util.Scanner(System.in);
		第二步：int num = s.nextInt();
						或： 
						String str = s.next();
*/

//----------------------------------------------------------------------------

//控制语句
/*
		关于java语言当中的if 语句，属于选择结果，if语句又被称为分支语句/条件控制语句
			1.if 语句的语法结构：四种编写方式
				第一种:
					if(布尔表达式或者是布尔结果)
						java语句;
						java语句;
						.........
				第二种：
					if(布尔表达式){
					java 语句;
					.........
					}
					else
					{
						java 语句;
						java 语句;
						........
					}
				第三种：
				if (布尔表达式)
				{
				java 语句;
				java 语句;
				}
				else if()
				{
				java 语句;
				}
				.......
			第四种：
		 		就是比第三种最后多了
		 		else
		 		{
		 			java语句;
		 		}
		2.重点，对于java中的if语句，只要有一个if语句被执行，整个if语句全部结束
		3.以上第二种编写方式和第四种编写方式都带有else 分支，这两种方式可以保证一定执行有if分支语句
		4.所有的控制语句都可以互相嵌套使用
		注意：嵌套使用的时候，代码格式要保证完美！ 【该缩进的时候必须缩进】
	
		if(){
				if(){
						if(){
							
						}
				}
		}else{
				if(){
					
				}else{
						if(){
							
						}
				}
		}
		
		5.if语句中的分支中，只有一条java语句的时候，大括号可以省略不写;
		
		/*
		if语句
		1.if语句如果后面不加{}，属于if语句的只有紧跟着后面的一句语句，
		其他语句不受if的影响（意味着必定执行）
		

*/
		
-----------------------------------------------------------------------
/*
		关于Switch语句
			1.switch属于选择结构，也是分支语句
			2.switch语句的语法结构
				一个比较完整的switch语句结构:
					swtich（写int或String类型的字面值或变量）{
						case int或String类型的字面值或变量:
							java 语句;
							java 语句;
							.....
							break;
						case int或String类型的字面值或变量:
							java 语句;
							java 语句;
							.....
							break;
						case int或String类型的字面值或变量:
							java 语句;
							java 语句;
							.....
							break;
						case int或String类型的字面值或变量:
							java 语句;
							java 语句;
							.....
						default :
							java 语句;
							.......
					}
			2.swtich 执行原理：
				swtich 后面小括号当中的数据与case后面的数据进行一一匹配（自上而下）
				成功则执行case后面的语句。
				
			3.分支当中最后有"break",执行break，则跳出swtich语句
			4.执行的分支中没有break，则直接再继续（无条件）执行下一个分支，（不用进行匹配）
			这种现象叫做case穿透现象，提供break;语句可以避免穿透
			5.所有分支都没有匹配成功，当有default语句，就执行default语句。
			6.（）里面只能是int 或者string 类型的数据，不能是其他类型数据
				当然byte short char 也可以直接写道switch 和case后面，因为他们可以实现自动类型转换
			7.case可以合并
				int i = 10 ;
				switch(i){
					case 1 : case 2 : case 3 : case 10 ：//表示 case 1  2 3 10 都可以走 当 int i =  1 2 3 10 
						System.out.printlln("")
				
									
----------------------------------------------------------------------
		
	/*
		关键字是蓝色 swtich  关键字都是小写 
		String确实可以探索字符类型
		
/*
		for
		1.循环结构：
			循环语句联合计数器，共同控制需要反复执行的代码
		2.基本上所有的编程语言支持
			for
			while 
			do while 
		3.for 循环：
			语法结构：
				for(初始化表达式;布尔表达式;更新表达式){
				 //需要重复执行的代码片段【循环体：由java语句构成】
				 
				}
		4.for循环执行过程/执行原理
			4.1、初始化表达式、布尔表达式、更新表达是都不是必须的！
			但是分号式必须的，
			4.2、初始化表达式最先执行，并且只执行一次
			4.3、布尔表达式必须是true/false,不能是其他值
			4.4执行过程：
				执行初始化表达式
				判断布尔表达式真假
					是真:则执行循环体
							更新表达式
						判断布尔表达式真假
							真：执行循环体
								更新表达是
							假：结束循环体
							......
					是假：循环结束
			
		 i = i++

*/		

/*
		java while循环语句
			1.语法结构
				while（布尔表达式）{
				 循环体
				}
			2.原理
				先判断布尔表达式的结果
					真：
						执行循环体
							判断布尔表达式结果
								真：。。。
								假:循环结束
										
					假：循环结束
			3.循环次数 0~n次
		
		
		
*/
------------------------------------------------
/*
			do while 循环：
				1.do..while 语法结构：
					do{
					循环体
					}while(布尔表达式);
			 2.执行原理：
			 	先执行循环体
			 	真：循环体
			 		真：循环体
			 			真：循环体
			 			假：结束
			 			
			 		假：结束
			 			
			 	假:结束
			 
			3.执行次数 1~N次
			4.注意事项：
				do..while 循环语句最终有一个分号别丢了  
*/

/*	
		关于java当中的当中的break语句
			1.break：中断/折断
			2.break ;  可以成为一个完整的java语句
			3.break使用在switch 语句当中，用来终止switch语句
			4.break可以用在循环语句当中，终止循环
			5.**break终止哪个循环
				默认情况下 ，终止离break最近的循环
				也可以指定终止某个循环，给循环起名 A:for A：while      break A ;
					
			
	
*/

/*
		continue语句
		1.表示继续/go on /下一个
		2.continue; 构成一个单独的完整的java语句，主要出现循环语句当中用来控制循环的执行
		3.break和continue 的区别？
			*berak 表示中断，不执行了
			*continue 表示直接进入下一次循环继续执行
		4.
*/

===========================================================================
方法
/*	
		以下程序不使用“方法”，分析程序存在哪些缺点
		 *代码没有得到重复使用
		 *要使用某个功能，只需要给这个功能传递某些数据
		 这样代码就可以重复利用，提高代码复用性
		使用这种方法，叫做调用/invoke 
		
*/
		/*

		以下直接使用方法这种机制，分析程序的优点
			代码得到了重复使用
		方法就是一段独立的代码片段，并且这段代码可以完成某个特定的功能，并且可以
		被我们重复使用。
		
		方法定义在类体当中，一个类当中可以定义多个方法，编写的位置没有先后顺序。
		
		方法体中不能再定义方法。
		方法体中的代码有java语句构成，自上而下顺序构成
		
		
*/


/*
		关于java 语言当中的方法
			1.方法怎么定义，语法结构
				[修饰符列表] 返回值类型 方法名（形式参数列表）{
				方法体;
			2.对以上语法结构进行解释说明
				2.1 关于修饰符列表---》统一写成 public static ，可选的 不是必须的
				2.2 方法的修饰符的列表当中有static关键字的话，怎么调用？
					-类名.方法名(实际参数列表);
				2.3 返回值
					*什么是返回值？（字面值）
					一个方法是可以完成某个特定功能，这个功能结束后大多数需要返回最终执行结果
						，执行结果可能是一个具体存在的数据，数据就是返回值
					*返回值有类型，
					*返回值类型都可以指定哪些类型？
						包括 基本数据类型和引用类型
					*有可能方法执行结束后不返回任何数据 ，
					当一个方法执行结束后不返回任何类型数据的时候，一定要写void
					
					*返回值若不是void ，表示这个方法执行结束后必须返回一个具体的数值
					否则编译器报错
					
					*返回值类型定义 和 返回类型的要一致
					
					
					如何写返回值？
					 retuen 值 ;
					 
					只要带有return关键字的语句执行，return所在的方法结束。
					
			3.方法名:一个合法标识符就行（首 小 后面首 大），一般方法名是动词?
			
			  方法体必须由大括号括起来，方法体中的代码由顺序 
			
			4.形式参数列表（形参）
				形参是局部变量 int a; double b ,float .....
				形参的个数可以是0-n个
				多个形参之间用逗号隔开
				形参中起决定性作用的是形参的数据类型
				例如
				形参和实参 类型对应相同，个数相同
				
			5.方法怎么调用？
				方法只定义不调用是不会执行的
				语法规则：方法的修饰符列表当中由static 
					类名.方法命（实参列表）;
	
			
					
								

*/
//public 表示公开的
//class 表示定义类
//MethodTest03 是一个类名

public class MethodTest03{
	//类体，不可以写java语句 ，可以声明变量
	//方法体出现在类体里面
	//static 静态的
	// void 表示不返回任何数据
	//main 是方法名 主方法
	//（String[]args ）：形参列表， String[]是一种引用数据类型，args是一个局部变量的变量名
	//以下只有args 这个局部变量的名字可以随意的	
	//主方法就是要这样固定编写，这是程序的入口【sun规定】
	
	public static void main(String[]args){
	
		//这里的程序是一定会执行的
		//main 方法是JVM负责调用的，是一个入口
		//用来调用其他的方法
		//类名.方法名（实参）;

/*
	方法调用
	1.方法的修饰符列表当中有static关键字，完整的是调用方式是类名.方法命（实参）
	2.但是以下情况可以省略：
		

*/

/*
		建议一个java源文件当中只有一个class 
		分析以下程序得输出结果
		main b 
		m1 b
		m2 b
		m3 b 
		m3 o 
		m2 o 
		m1 o 
		m  o 
		对于当前得程序来说，main 最先调用，最后结束。
		最后调用得是m3，
		
		main 方法结束后，整个程序结束了，这句话只适合当前所讲内容。
*/

/*
		一个方法有返回值的时候，当我们调用的时候，方法返回了一个值，对于调用者来说，
		这个返回值可以接受，也可以选择不接受，但是大部分情况下，都会接收。
		
*/


/*
		深入return语句
			*带有return关键字的java语句 只要执行，所在的方法执行结束。
			*return后面的语句都执行不了 所以编译报错。
*/

/*
		在返回值类型是void 的方法中使用"return"语句
	 “return”语句出现在返回值为void的方法当中主要是终止方法的执行。 
	 不要加任何值
	 	

*/
/*
		方法在执行过程当中，在JVM的内存是如何分配的，内存是如何变换的？
		1.方法只定义，不调用---》所以不会执行，不会占用空间
		2.在JVM内存划分上有三块主要的内存空间：（当然除了这三块还有其他，，主要）
			*方法区内存
			*堆内存
			*栈内存
		3.关于栈数据结构
				*栈：stack 是一种数据结构
				*数据结构反映的是数据的存储形态
				*数据结构是独立的学科，不属于任何编程语言的范畴，只不过大多数编程语言当中要使用数据结构
				*作为程序员需要提前精通：数据结构 算法 计算机专业必修一门课程
				*常见的数据结构
					-数组
					-队列
					-栈
					-链表
					-二叉树
					-哈希表/散列表
					.......
		4.栈帧 
				栈帧永远只想栈顶原色
				栈顶元素永远处于活跃状态，其他元素静止
				术语：
					压栈/入栈/push
					弹栈/出栈/pop
				栈数据结构存储数据的特点是：先进后出 后进先出
		5.方法执行的时候，执行过程的内存在哪里分配
				*方法代码片段 属于.class一部分，字节码文件在类加载的时候，//方法区内存放代码
				将其放在方法区当中，所以JVM的三块主要的内容空间中，
				方法区最先由数据，存放了代码片段
				*代码片段虽然在方法区内存中只有一份，但是可以被重复调用
			  *每一次调用这个方法的时候，需要给该方法分配独立的活动场所，在栈内存中分配
				 即为变量开辟的占用的空间
		6.方法在调用的时候，会给方法分配独立的内存空间，在栈中分配，此时发生压栈动作，方法执行结束后，
		给该方法分配的内存空间全部释放，此时发生弹栈动作。（这里主要是栈内存发生变化）
			压栈：给方法分配内存空间
			弹栈：释放方法的内存空间				
		7.局部变量在栈中存储，局部变量在运行阶段在栈中分配
		以上的要理解的背
				在执行过程中，main 最先执行，所以首先分配到栈的底部，最后到（顶部）最后调用的方法;
				只要调用方法就压栈。所以最先调用的方法最后才释放，最后调用的最先释放。（在顶部）
				
				
*/
	/*
			
			1.方法体
				方法执行过程中的内存分配
			2.方法的重载机制
			3.方法的递归调用
*/


/*
			以下代码不使用方法重载机制，即overload，有以下缺点
						1.以下三个方法功能不同，但是都是求和

				2.对于程序员来说，记忆不方便
				3.功能相似，方法不同，有一个机制，可以使得在编写程序时，
				就好像调用调用一个方法。
				//最终希望达到的效果时候，程序在使用多个类似功能的方法时，就好像调用一个方法，通过使方法名一样
			
*/
/*
		方法重载：
			1.方法重载:overload 
			2.什么时候考虑使用方法重载？
			3.什么条件满足之后构成了方法重载
					-在同一个类当中
					-方法名相同
					-参数列表不同
							数量不同
							顺序不同
							类型不同
							
							
			4.方法重载和什么有关系？和什么没关系
					*方法重载和方法名+参数列表有关系
					*和返回值类型无关系
					*和修饰符列表无关//无关，意思是 无法借此来区分两个功能相似但功能不同，名字相同
					的方法，所以就会出现问题，所以 方法重载只和方法命和参数列表有关，
*/

=============================================
递归

/*
		关于方法的递归调用
		递归：方法自身调用自身
		递归很耗费内存，可以不用尽量别用
		*递归一定要有结束条件，否则会发生栈内存溢出 JVM将会停止运行
		*递归即使有了结束条件，即使是正确的，也可能发生栈内存溢出
		因为递归的太深了
*/




=====================================第三章===========================================
总结第三章的内容：
	面向对象和面向过程的区别
	面向对象的三大特征
	OOA OOD OOP 
	类和对象的概念
	类的定义
	对象的创建和使用
	JVM内存管理
	参数传递
	面向对象的封装性
	面向对象的继承
	面向对象的多态
	this 关键字
	final关键字
	访问控制权限修饰符
	构造函数
	方法的重写/覆盖
	package 和imoport
	
一、面向对象
/*

		对象的创建和使用
*/

public class OOTest01{
	public static void main(String[]args){
	
		//通过一个类可以实例化n个对象
		//实例化对象的语法是： new 类名（）;
		//new 是java语言的一个运算符
		//作用是创建一个对象，在jvm堆内存当中开辟新的空间
		//方法区内存：在类加载的时候，class字节码代码片段被加载到该内存空间中
		//栈内存：方法代码片段执行的时候，会给该方法分配内存空间，在栈内存中压栈
		//堆内存：new的对象在堆内存中存储
		// Student 是一个引用数据类型，类似 int long ，
		// s 是一个变量名
		// new Student（）是一个学生对象
		Student s = new Student();//引用了Student.class 通过new 创建了对象
		// s 称为引用，在堆内存中储存的是对象，对象的内存地址给了 s 保存，通过赋值等号给的
		//什么是对象？new 运算符在堆内存中开辟的内存空间称为对象
		//什么是引用？引用是一个变量，只不过它保存了另一个java对象的内存地址
		//java程序员不能直接操作内存，不像c语言有指针，
		//只能通过“引用”去访问堆内存当中对象内部的实例变量
		//访问实例变量的语法格式是：
		// 读取： 引用.变量名 ;
		// 修改： 引用.变量名= 值 ;
		 int stuNo = s.no;
		 String stuName = s.name ;
		 int stuAge = s.age;
		 boolean stuSex = s.sex;
		 String stuAddress = s.address ;
	/*
		 System.out.println("学号="+stuNo);// 0
		 System.out.println("姓名="+stuName);//null
		 System.out.println("住址="+stuAddress);//null
		 System.out.println("性别="+stuSex);//false
		*/
			 System.out.println("学号="+s.no);// 0
		 System.out.println("姓名="+s.name);//null
		 System.out.println("住址="+s.address);//null
		 System.out.println("性别="+ s.sex);//false
		 //上面的语法也行 
		 
		 //下面是修改：
		 s.no= 10 ;
		 s.name = "jack";
		 s.age = 20;
		 s.sex = true ;
		 s.address = "be";
		  System.out.println("学号="+s.no);// 
		 System.out.println("姓名="+s.name);//
		 System.out.println("住址="+s.address);//
		 System.out.println("性别="+ s.sex);//
		 //再通过类实例化一个全新的对象
		 Student s1 = new Student();
		 //s1 是一个引用，同时也是一个局部变量
		 //Student 是变量的数据类型
		 
		 
		 //下面的语句错误
///		   System.out.println(Student.no);
		//no 这个实例变量 不能直接采用 类名的方式 访问
		// 因为no 是实例变量，对象级别的变量，变量存储在java对象的内部，必须现有对象
		//通过对象才能访问no这个实例变量
		 
		 
		 
		 
		 
		/*
		成员变量默认赋值:
		数据类型           默认值
-----------------------------------
		byte short int long     0
		float double           0.0
		boolean                 false
		char                    \u0000
		引用数据类型	 	 				null 空值
				
		*/
		//所以现在堆内存中，当new 一执行，就会有空间，里面就是no =0 ， sex = false  age =  0  name = nill
		//address = null  //引用数据类型的默认值是null 
	}
}
/*
		局部变量在栈内存中存储
		成员变量中的实例变量在堆内存的java对象内部存储
		
		实例变量是一个对象一份，100个对象有100份

*/
//----------------------------------------------------------------------------

public class OOTest02{
	public static void main (String[]args){
		//创建 User 对象
		User u = new User ();
		u.no = 110;
		u.name = "jack";
		//这里要稍微注意一下，创立新对象不一样要new  
		//字符 串有特例， 只要是 字 符串，就会创了一个String ，他的地址放在了 User 的name的位置
		//引用可以是局部变量 也可以是实例变量
		System.out.println(u.no);
		u.name = "jack";
		
		s
		u.addr = new Address();
	}
}
-----------------------------------------------------------------------------------
public class OOTest03{
	public static void main(String []args){
		User u = new User();
		//u.addr = new Address ();
		Address a = new Address();
		u.addr = a ;
		System.out.println(u.addr.city);//null
		System.out.println(a.city);//null
		a.city = "天津";
		System.out.println(u.addr.city);//虽然改的是 a.city 但是因为 u.addr 里面放的就是 a 里面的
		//address 对象，所以 a.city改了后，u.addr指向的address 也改了 所以也是 天津
		u.addr.city = "佛山";
		System.out.println(a.city);
	//u.addr.city就是 详细城市的地址位置， 这里改了，原本指向 address对象的 a.city也会改了
	//上面的两种情况，都是因为对象改了，所以另外其他指向同一对象的也会改。本质是指向没有改变
		
		
	}
}
-------------------------------------------------------------------------------
//

public class OOTest04{
	public static void main (String[]args){
		
		//创建一个丈夫对象
		Husband hxm = new Husband();
		hxm.name = "黄晓明";
		Wife b = new Wife();
		b.name = "baby";
		//创建一个妻子对象
		//然后结婚：能通过丈夫找到妻子，反之亦然
		hxm.w = b;//关键步骤: hxm.w的位置存放了 b 对象地址，可以访问 b 对象有的属性
		b.h = hxm;//关键步骤.b.h 的位置存放了 hxm 对象地址，可以访问hxm对象有的属性
		System.out.println(hxm.name+"的妻子是"+hxm.w.name);
		System.out.println(hxm.name+"的妻子是"+b.name);//这样是不好的 因为 体现不了两者关系
	}
}
/*
	方法调用的时候，该方法所需要的内存空间在栈内存中分配，称为压栈，方法执行结束后，该方法所属
	的内存空间释放，弹栈
	
	栈中主要储存的是方法体当中的局部变量 
	
	方法的代码片段以及整个类的代码片段都被存储到方法内存当中，在类加载的时候这段代码会载入
	程序执行过程中使用new运算符创建java对象，存储在堆内存中，对象内部有实例变量，实例变量存储
	在堆内存中，
	7.变量：
			局部变量：存储在栈内存 （因为局部变量在方法体内声明）
			成员变量：方法体外（方法外，例如static int i ;
					实例变量【修饰符前面没有static】
					静态变量 有static
						静态变量存储在方法区内存中 
	8.三块内存中，变化最频繁的是栈内存的局部变量，首先有数据的是方法区内存，垃圾回收器主要针对的是堆内存
	9.垃圾回收期【自动垃圾回收机制、GC机制】，什么时候会考虑将某个个java对象的内存回收呢？
		当堆内存当中的java对象称为数据的时候，会被垃圾器回收
		什么时候堆内存的对象会变成垃圾?
				没有更多的引用指向它的时候//即没有人指向它 不是没有特别多  
				这个对象无法被访问，因为访问对象只能通过引用的方式访问
				*/

public  class OOTest05{
	public static void main (String[]args){
		 Customer c  = new Customer();
		 System.out.println(c.id);//0
		 c = null ;
		 //空引用，访问“实例”相关的数据一定会出现空指针异常
		 //实例相关的数据表示，这个数据访问的时候，必须有对象的参与，这种数据就是实例相关的数据
		 //以下程序编译可以通过，符合语法
		 System.out.println(c.id);//编译没问题，但是java 运行有问题，
		 //因为c没有指向对象了 ，所以被垃圾回收器回收
	}
}
/*

每一个类中都可以有主方法，但一般情况下，一个系统只有一个入口，所以主方法一般只有一个
*/
public class ProductTest{
	public static void main (String[]args){
		// 创建商品对象
		//iPhone7 局部变量 引用 保存内存地址 指向 堆内存当中的商品对象
		Product iphone7 = new Product();
		System.out.println("商品的价格是："+iphone7.price);
		System.out.println("商品的价格是："+iphone7.id);
		
		iphone7.price = 5124;
		iphone7.id = 8;
		System.out.println("商品的价格是："+iphone7.price);
		System.out.println("商品的价格是："+iphone7.id);
		//下面编译报错，实例变量必须先创建对象，通过引用的方式访问，不能直接使用类名.方式访问
		//System.out.println(Product.price);
		// ProductTest.java:18: 错误: 无法从静态上下文中引用非静态 变量 price
		//就好像去商场买东西，问服务员 多少钱  这就是个问题， 要先知道是什么对象？（什么商品）才可以访问
		
  }
}

/*
java语言是面向对象
想创建对象，必须先定义类
定义类的语法：
	【修饰符】 class  类名{
			属性；
			方法；
	}
	属性通常是变量----表示--》状态信息
         变量有类型：1.基本数据类型+引用数据类型
   例如每一个商品都有一个编号，每一个商品都有单价  所以定义以下的类
*/
public class Product{
	
	int id ;
	double price ;//实例变量 ==对象变量
	
}
============================================================================
集成：
/*
			1.java的集成开发环境[集成开发环境简称：IDE]
				1.1什么是集成开发环境？讲究一站式开发，有提示功能，有自动纠错功能
						*集成开发环境可以让软件开发变得更简单 搞笑
						*没有IDE:
							 需要安装JDK,需要配置环境变量，需要手动将java源文件编译生成class字节码文件
							 java源程序出错之后还没有提示
						*有IDE工具：
								不需要独立安装JDK
								不需要手动配置环境变量
								不需要使用javac命令对jav按原文件进行编译
								使用IDE工具有许多代码不用写，自动生成了
				1.2java 有哪些比较牛得IED
					eclipse【最多】 
					myeclipse
					NetBeans
					.....
	
	2.myeclipse的使用：
				

	3.面向对象得封装性				
			workspace是工作区 
				选择了工作区，将来编写java代码，自动编译的.class文件都在会工作区找到
		在workspace工作区当中有一个文件夹，.metadata 
			在该文件夹存储了工作状态（即 布局，如果删掉了之后会重新布局）
		
		窗口不小心关闭了 可以再次打开，
		 window->show view --->other 
		 
		右上角的open perspective  可以把整个界面切换到不同的工作状态
		
		window -- reset perspective 
		
		重点的窗口介绍:
			Package Explorer/Nvigator /Project Explorer 都可以看到java 源文件
			Console 控制台窗口
			
			工作区最基本的单元式：Project （工程/项目）
		 		--指定java工程名称
		 		--指定java文件存放目录
		 		--java的运行的环境 可以式eclipse 提供的 也可以是自己原本安装的
		 		--project layout ：目录的工程布局 
		 				选择独立的文件夹，存放源码（src）和字节码（bin）
		 在src目录下新建软件包，package机制后面讲
		 	在src目录上右键---》package
		 在package上右键新建一个java类.class【同时生成了main方法】
		 
		 ctrl+d ：删除一行
		 alt + / ： 自动补全
		 
		 java 保存了就自动编译 
		 
		 红色下划线 代表语法错误  
		 ctrl + 1  纠错
		 有时候出现黄色下划线 警告 编译可以通过	
		 ctrl + alt + ↓ ： 复制黏贴当行到下一行
		 
		 ctrl +shift +F 格式化 使间距 行间距 变得合理 
		 
		 某一行 alt + 上下可以切换行
		 快捷键可以设置  window-Pre....
		 ctrl + / ： 添加/取消注释
		 ctrl + alt + / ： 多行注释的添加或取消
		 
		 查看访问的是哪个属性，哪个方法，
		 	//按住ctrl键，把鼠标移到相应位置，出现下划线的时候，点击左键
		 
		 ctrl + o 可以查看本类的所有元素，然后要输入要查找的元素名称，
		 
		 怎么运行带有主方法的java程序
		 		在java源程序的任何位置右键，---》run as 
		 
		块编辑：快速编辑 支持多行同时编辑， 菜单栏蓝色方块
		
		4.构造方法
		
		5.对象和引用
			5.1 对象和引用的概念
				*对象： 目前在使用new运算符在堆内存中开辟的内存空间称为对象
				*引用：	是一个变量，不一定是局部变量，还可能使成员变量，引用保存了内存地址，指向了堆内存当中的对象
					*只有一个空的引用，访问对象的实例相关的数据出现空指针现象 相当于 User u = null ;
			例如： class Student{
								Computer com ; // com 是一个引用 【实例变量】
								
								public static void doSome(){
									Computer cc ; //cc是一个引用【局部变量】
								}
			}
			
			5.2 参数的传递？
				主要研究和学习的是方法在调用的时候，涉及到参数传递的问题，到底是怎么样传递数据的
				package day09.javase.day09.test006;
//研究参数
public class Test02 {

	public static void main(String[] args) {
		User u = new User(20);//局部变量都是在栈内存啊！
		//区分 i = 10 ; 这里 i 是个局部变量，有一个地址，存放了10 这个字面值
		//而 User u =   u是变量 也有地址，u保存的值是一个特殊值，然是java对象在堆内存中的内存地址
		//所以 0x124 和 u 是同等地位的 
		//所以是两个地址
		add(u);//传递了 u 变量中保存的值，有时候 这个值 是 10 .。也可能传的是 一个java对象的地址
		System.out.println("main---->"+u.age);//21  
		
	}
	public static void add(User u) {//这里 写User u 看自己能不能分得清到底是怎么回事！！！这点很重要
		//其实 这里 写其他字母都没所谓，关键是下面一句，u.age  如果上面是User s ，下面也是 s.age
		//这代表，在 add方法里面开辟了一个叫 u 的 局部变量，保存了 上面传过来的“User u” 里面的地址
		//相当于，一共有两个局部变量，分别在main 和add方法中，都指向了 堆内存当中的User 对象
		//不同的只是 一个在main ，叫u ，一个在add 也叫u， 所以，当 add方法中的u.age++;执行，代表指向堆内存的
		//对象的那个age值+1， 如果把变量名字改改， User s  ,s.age++ 同样 ， 因为两个方法中的局部变量存放的值：
		//同样是那个对象的地址，只是变量名不同，所以，引用时不用，关键看怎么声明，
		//main 是 User u ，而add 是（User u），也可以写成 User sss, sss.age++;  调用：引用.变量
		u.age++;   
		System.out.println("add---->"+u.age);//21
		
	}
	

}

class User {
	
	//实例变量
	int age ; 
	
	//构造方法
	public User(int i ) {
		age = i ; 
	}
}


*/
===================================================================================
面向对象三大特征： 1、封装
/*用户测试
//对于当前程序来说 User类的age属性在外部程序中可以随意访问，导致age的属性不安全
//一个User对象表示一个用户的属性，age 不可能为负数，以下程序当中年龄值为负数，
//程序运行没有报错，所以使不安全的
//面向對象包括三大特征：
	-封裝
	-繼承
	-多態
當前主要講的是封裝機制，爲什麽要運用封裝？封裝有什麽好處
	1.对于事物来说，看不到复杂一面，只能看到总的一面
		复杂性封装，对外提供简单的操作入口，照相机就是一个很好的封装案例，
		照相机的实现原理非常复杂，但是使用起来非常简单方便
	2.封装之后才会形成真正的对象，真正的独立体
	
	3.封装就意味着以后的程序可以重复使用，并且适应性强
	4.封装之后事物 安全级别提高
	5.
			
*/
public class UserTest {
	public static void main(String[] args) {
		// 创建User对象
		User yonghu = new User();
		// 访问age，读取年龄值 【get】
		System.out.println("该用户年龄是：" + yonghu.age);
		// 修改年龄值
		yonghu.age = 22;
		System.out.println("该用户年龄是：" + yonghu.age);
		//这里的age属性完全暴露给外部程序，对于程序员说可以操作User对象当中的所有细节，导致不安全
		//建议将user进行分装，建议外部不能随意访问User对象当中的属性
		yonghu.age = -100 ;
		System.out.println("该用户年龄是：" + yonghu.age);
	}
}
//======================================================================================
进阶视频笔记：
一、面向对象程序设计
	(一)相关概念
		 1.什么是面向对象程序设计？
		 	把一事物分解为若干个不同的对象，分析每个对象都有哪些行为
		 	面向对象程序设计就是以对象为中心，通过给对象发送消息解决问题
		 	
		 	如：模拟让小明帮忙订外卖
		 	
		 	
		 2.什么是面向过程程序设计？
		 	侧重解决问题的步骤
		 		如：模拟让小明帮忙订外卖
		 			1）下载app
		 			2）注册
		 			3）登陆
		 			4）点餐
		 
		 	
		3.类和对象
			万物皆对象
			
			类：对一组对象相同属性与相同行为的抽象
			可以把类看作是一个模板，对象就是这个模板的一个实例
			
			如所有同学都有属性：姓名，性别，年龄，成绩。。。。
			都有的行为：学习，吃....
			
			学生类{
					相同的属性
					形同的行为
			}
			在java定义中，先定义类，再通过类创建对象
			
		 
（二）类的定义与对象的创建
		
		定义类的语法：
			[修饰符] class 类名{
				属性保存在变量中
				行为用变量表示	
			}
			
			类可以看作 = 属性 + 方法;
			
			. 是一个成员运算符
				用法：类名.成员（成员变量）
							对象.成员 
							
		注意：		
			类体中只有成员变量和成员方法，不能有其他语句
			一个源文件只定义一个类
			单独定义测试类
			
（三）构造方法
1）作用：
	在创建对象的同时，给对象的属性赋值
2）特点
	1.构造方法名与类名相同
	2.构造方法没有返回值，没有返回值类型
	3.系统默认有一个无参构造方法（缺省构造器)
	4.当有了有形参的构造方法后，系统默认无参构造器不在了，在开发时，经常使用到无参，所以最好先定义出来
		无参构造方法： public 类名{
			
		}
	5.构造方法可以重载
	6，构造方法在创建对象时候，由系统调用
	
	
	
（四）this 关键字
	1）当方法的参数名/局部变量名与字段（成员变量）重名时候，通过this访问字段，this 代表当前对象
	如果是在构造方法中，this 当前对象就是new出来的对象，如果在普通的成员方法中，this就是调用该方法的对象
	2）在类的构造方法中，通过 this（），可以调用另外的构造方法，可以少些一些赋值语句，
	注意：this（）调用构造方法的语句必须作为第一条语句
	
	（无）对象参数
	对象可以作为方法参数，就像其他基本类型作为方法参数一样
	在调用方法时，把实参对象爨地给形参对象，实参对象保存得堆中对象得引用，传递给形参后，现在，
	形参与实参都指向了堆中同一个对象。
	在方法体中调用形参对象得方法，实际上也是调用实参对象得方法，
	在方法体中访问形参对象的属性，实际上就是实参对象的属性
	在方法体中对形参对象重新赋值//意思就是 比如 下面
	public void(Dog dog){
		dog = new Dog(实参 ，实参)；
	}  //---》形参就指向新的对象，不再指向实参对象
	相当于 堆内存 多了一个内存地址，指向了dog，所以不再指向实参 即本来的实参对象里面的地址，换了新的一个对象的地址了
	
	
	（六）static 关键字
		1.static 关键字可以修饰字段，修饰方法，修饰代码块，修饰内部类，实现静态导入
	public class  ssad(){
		
		  int x ;//成员变量，没有static ------>实例变量
    static int y ;//使用了static 修饰的成员变量 ---》静态变量
    //静态变量的特点：静态变量不属于某个具体对象，属于整个类的，所有对象共享
    //在加载内存时，给静态变量在方法区分配存储空间，
    //通过类名访问静态变量，也可以通过对象，但和对象没关系，因为是共享的

    //实例变量和静态变量的区别
//        ）存储位置不一样 实例--》堆
//                        静态--》方法区
//        2）使用方式不一样，实例只能通过对象访问
//        3）声明周期不同，静态变量在加载的时候就分配了，一直到结束，
//            而实例变量在创造对象的时候开始，当对象没有指向的时候释放就结束
				4)静态变量的应用场景
					1.当类的所有对象需要共享一个数据时，可以定义静态变量
					2.当所有对象的某个属性一样时，可以定义静态变量

	2.静态方法
		使用static修饰的方法就是静态方法，没有static 就是实例方法
			通过类名调用，																通过对象.调用
			建议不管在（除静态方法中）什么位置，调用静态变量都加上类名，这样可以看到他的性质
	3.静态内部类
		可以在一个类体中，再定义一个类，称 成员内部类
			static class xxx{
			
			}
			
			class xxx{
			
			}
			在什么情况下需要定义内部类？
					在描述一个大的数据结构时，它还包含一个小的数据结构，这些小的结构可以定义为内部类
						如：在医学上定义一个类，人还有心脏，可以把心脏类 定义为人 类 的内部类
						
			java中，每个类都会生成独立的字节码文件.class 
			格式：外部类名$内部类名.class
			
	（七）构造代码块
				{
					System.out.println("构造代码块，编译后，系统会把构造代码块编译到每个构造方法的前面");
					System.out.println("创建对象要调用构造方法，构造方法体执行前，会先执行实例变量的显示初始化，
					执行 构造代码块，  再执行构造方法的方法体 ")
				}
			
			static 构造代码块：
			static {		
			
				//特点：类加载内存时，只执行一次
					一般静态变量的定义在 静态代码块 之前 
创建对象执行顺序
1）把类加载 加载到方法区当中
2）把静态变量分配存储空间
3）执行静态代码块
4）new运算符创建对象，系统给对象的属性进行默认初始化
5)调用构造方法，在构造方法体执行前：
	先执行实例变量的显示初始化
	再执行构造代码块
	最后执行构造方法体
				System.out.println("静态构造代码块，就是使用static修饰的构造代码块")；
				System.out.println("静态代码块在类加载内存时只执行一次，一般在静态代码块中给静态变量赋初始化，
				二、是用来加载类依赖的外部资源，JDBC驱动程序 就是在静态代码块中加载的");
				有时候在类体中没有初始化静态变量。所以可以在静态代码块中写赋值语句
					}
（八）封装
	面向对象程序设计的特点：封装 继承 多态 
		封装：屏蔽细节
		继承：实现代码的复用，用来实现多态
		多态：提高程序的可扩展性
		
	1.封装：
		* 1)为什么封装
 *      用户赋值的数据可能时无效的
 * 2）如何封装
 *      使用private修饰字段为私有的，私有字段只能在 对象类体中使用
 *      提供 公共的setter 和 getter 来实现对字段的访问 ，所以就可以在方法体中对赋值的数据进行一定的过滤
	
	2.继承 
		2.1 作用：实现代码的复用，实现多态
		2.2 如何继承：子类 extends 父类
		 继承：
 *   son类继承了father
 *    于是 son--->子类
 *  子类继承了父类，会继承父类当中使用 public /protected 修饰的实例成员（官方）
 *   但是经过调试发现 子类会继承所有父类的实例成员，但不一定都有权限访问
 *   在java中，如果没有显示通过extends继承父类，默认继承Object；
 *   java中，类最多只能继承1个父类，只支持单继承，
 *   类的继承可传递，
 *   只有两个类两个类符合 ： 子类 is a 父类 ；
 *   子类是父类的一种， 如  人是动物  即 小--》大
 *   学生是人     小学生是学生  
 	 2.3 构造方法不能继承
 	 		子类创建对象要调用子类的构造方法，子类构造方法执行前会先调用父类的构造方法（语法）
 	 		默认情况下，调用父类的无参构造器，如果父类没有无参构造器，系统报错
 	 		在子类构造方法中，可以通过super（）显示调用父类的构造方法
 	 		解释为什么：首先 子类的变量肯定大于等于父类的 毕竟还有新添的，
 	 		在创建类对象的时候，如果没有继承，那么直接调用的是子类的构造方法，进行变量的初始化
 	 		如果类是子类，创建子类对象的时候，肯定先调用父类，因为父类中的变量也要初始化，
 	 		如果父类没有无参构造，那么那些变量就没有的到初始化 或者按照求的赋值，而子类中
 	 		的全部的变量也无法得到全部的初始化，报错
 	 		
 	 2.4 静态成员没有继承
 	 public class Test {
    public static void main(String[]args){
        Son s1 = new Son();
//        s1.x =123;
//        System.out.println(Father.y);
//        System.out.println(s1.x);//实例变量 即没有static   有static -->静态变量 二者都是 成员变量
//        System.out.println("====================");
//        System.out.println(Son.y);//这里也可以用 子类.的方法去调用父类的static 变量，但是这里不是继承 是调用
     //       运行后只执行了父类的静态代码块，没有son的静态代码块，说明son的类没有加载到内存
       //说明son.y 的y 不是son中的一个变量，如果是的话，son类要加载到内存中，就会执行 son中的static {}

	2.5 方法覆盖
			为什么要方法覆盖？
			// ==当子类从父类继承的方法不能满足子类的要求，可以在子类中重写该方法
			
			    //方法覆盖
    public void show() {
//        super.show();//通过supper关键字 表示这个show（）是继承来的
//  如果不写这行，就是形成了方法覆盖，相当于只有一个show
        System.out.println("s1="+s1);
        System.out.println("s2="+s2);
    }
    
    supper. 关键字 表示继承来的方法 而不是本类的show ，否则就show{
    	show  //就递归调用--》栈溢出
    }
    
    方法覆盖的规则：也叫方法重写：
    		1）方法签名必须相同： 方法签名= 方法名+参数列表
    		2)	返回值类型可以相同，也可以是子类型
    		3）访问权限可以相同，也可以更大
    		4）抛出的异常，可以
    
    2.6 访问权限
    		类的访问权限：公共类和非公共类
    		public  和 没有 用public 
    		
    		没有使用public ，则该类只能在当前包中使用
    		
    		类成员的访问权限
    		
   类成员的访问权限      当前类  当前包    不在当前包中的派生类   其他没有继承关系的类
-----------------------------------------------------------------------------------------
		私有，private 	       可      否          否												否
		默认的 没有权限修饰符   可			可					否											否
   受保护的 protected				可		可					 可											否
   public																全可以

    		
    public  任意位置
    protected  当前类和子类
    默认			当前包中使用
    private		当前类中 		
    		
    		
   2.7 super 关键字
   		用途： 1）在子类构造方法中，通过super（），显示调用父类的构造方法，super必须作为子类构造
   		方法的第一条语句 
   		2）子类的类体中，通过super表示该成员是从父类继承来的
   		super 跟父类对象没有任何关系
   		
   		this 关键字 与 super关键字的区别
   		this： 1）在构造方法中，通过this（）调用当类的其他构造方法
   				比如  定义了一个无参构造器，和一个有参的， 当无参构造器需要默认初始化一些值得时候，可以通过this(xxx,x,xx)来实现对某些之得初始化
   		2）当参数名/局部变量名与字段重名时，通过this访问字段
   		
   		super ：当子类构造方法中，通过super（）显示调用父类的构造方法
   		2)当子类中定义的某个成员与从父类继承的成员重名，通过super表示是从继承来的
   		
   		在子类构造方法中，不能同时使用this 和super
   		this 代表当前对象， super 跟父类对象没有关系
   		
   		
   		
   		
   （九）final 关键字
   
   		可以修饰类，字段，方法，修饰局部变量和形参
   		
   		如果修饰类，表示该类是最终类，不可以被继承了
   		如果是字段，必须给字段显式初始化，或者在构造方法赋值，不能重新赋值 
   		如果是方法，则无法被子类覆盖 （重写），但可以被子类继承，（前提不是static 的方法）
   		即子类可以继承final修饰的方法，
   		如果是形参，在方法体中不能对final参数重新赋值，因为在调用的时候就传值了
   		如果是局部变量，一般在定义的时候就赋值
   		如果修饰的是引用类型的变量，如 final Dog dog =new Dog（10） ；
   		则 dog 不能再被赋值，但 dog.age 可以赋值，因为age 的属性，没有使用final修饰
   		
   		
   	（十）Object类
   		如果一个类没有通过extends  显示继承父类，则默认继承Object
   		Object类是所有类的根父亲
   		继承是可传递的
   		
   		查看API是java一个使用说明书，学习java的参考文档
   		
   			
   public class Test01(){
   		public static void main(String[]args){
   			Person p1 = new Person();
   			System.out.prinltn(p1);
   			
   				
   				原理：1)当使用System.out.println(p1),打印对象，在println（）方法体中，调用了
   				String.volueof()方法，把对象转换称字符后再打印
   				2)在string类的Valueof（）方法中，调用的Object 使用 Object类继承而来的
   				3）在Object类中的toString（）默认返回以下内容：
   						return getclass（）.getName（）+"@"+Integer.toHexString(hashCode));
   										   	完整类名				+		@		+哈希码的十六进制
   				
   				结论：当使用System.out.println 打印对象时，就会调用对象的toString（）方法
   				需求：打印对象的各个属性，那么就要对toString方法就行重写，其实就相当于
   				每个员工的结算工资不同，就把父类的方法重写（重载）
   				
   				所以在子类加上以下方法：
   				@Override
    public String toString() {
       // return super.toString();
       return "...."+。。。    
    }
   			*/
   		}
   }
    equals()方法
    	如果要判断类的两个对象内容是否一样，需要重写equals（）方法
    	根据哈希约定，如果两个对象equals（）相等，着两个对象的哈希码也应该相等，所以
    	一般在重写equals（）方法的同时，也重写hashcode（）方法
   				
   				
   **** 
   实体类： 类似student book  car 这些类（通常会按照以下模板定义）
   		1）把所有的字段私有化
   		2）一般只提供无参构造
   		3）重写toString
   		4）重写equals（）/hashCode（）
   		5）提供公共的 setter和getter
   		
   				
 三、多态
 3.1	多态又分为：对象多态 、行为多态
 		对象多态：指同一个学生有不同的状态，时通过对象转型实现
 				如 人在学校是学生，在家是。。在。。。又是。。身份
 		行为多态：相同的语句执行不同的操作
 				分为：编译时多态，和运行时多态（通过重载实现）
	 				编译多态：在编译的时候就能确定执行哪个方法，称为静态多态
 					运行多态：在运行阶段才能确定运行哪个对象的方法，也称动态多态
 			不特殊说明：平时说的多态==动态多态 运动多态
 			
 3.2 对象向上转型：  
 	 		父类 引用 = new 子类 
 			父类 引用= 子类引用
 		对象向下转型：
 			 1）对象向上转型的逆操作，必须先有向上转型，才能实现对象向下转型
 				当父类引用指向子类对象之后，如果想要访问子类特有的属性，方法，就需要对象向下转型
 			2)	实现方法：
 				如 ： Dog dog = （Dog）pet ；
 						dog.方法名；
 						或者一步 ((Dog)pet).方法名；
 						
 	
3.3多态的条件
	1）子类继承父类 extends
	2）子类重写父类的方法  public ....
	3）父类的引用指向子类 	父类 = new 子类 或者 父类 引用= 子类引用 
	4）通过父类调用被重写的方法，实际执行的是子类的方法  父类.方法			
 	
 3.4多态的作用
 		面向抽象编程可以提供代码的可扩展性，降低类之间的耦合度
 		
 		public class Test01 {
    public static void main(String[]args){
        Pet p1 = new Dog("xb");
        //p1实际引用的是Dog 对象，但是pet引用是Pet类定义的，通过Pet引用只能访问Pet类的成员
        //需求，让pet引用dog对象看门
        ((Dog)p1).guard();
        //为什么不直接 new狗对象，然后狗的对象再去调用狗的方法呢？非得通过父类 然后去调用子类的对象？
        p1.feed(p1);
        //因为定义了宠物类，包括许多子类的宠物 猫狗蛇....然后通过向上转型，使得可以调用子类的方法
        //继承与多态是相辅相成的 有了继承，才谈多态，
        // Pet p1 = new Dog(),向上转型，子类继承了父类的属性，实现多态 ，所以在这基础上，就不是直接定义出一个具体的宠物，而是一个抽象的类
        //通过抽象的类去编程，提高可扩展性，降低耦合度，前提是有继承，再有多态，
        Dog d1 = new Dog("sw");
        d1.guard();
        //这种耦合度很高
        
        必须先有向上转型，才能向下转型
        
        而且一般在向下转型的时候，会通过instanceof运算符判断堆中对象的类型是否为目标类型
        		引用 instanceof 子类  即  定义出来的对象 是否指向一个子类
        如：  Pet p1 = new Dog("xb")
         if(p1 instanceof  Dog){//pet 而实际引用的对象是dog 即--》  Pet p1 = new Dog("xb");
            ((Dog)p1).guard();
        }
        if(p1 instanceof  Cat){
            ((Cat)p1).catchMouse();
        }
      
    }
    总的来说，向上转型 解决这一类问题：多种子类有共同点，定义一个父类出来，然后通过父类去
    实现不同子类的方法  一个父类可以实现有共同点子类
    而向下转型，是针对父类想访问子类的特殊属性，人是父类，子类是学生，学生有学号，人有姓名
    而且学生有学号和姓名，但是人本来没有学号，通过 人 ren = new 学生（);//向上
    再通过 （学生）ren）.学号  来访问学生的学生，不能直接ren.学号，因为父类没有
    注意：如果子类实现了向上转型，父类虽然指向了子类，但父类就失去了使用父类中所没有的方法的使用权
    而向上转型的一个好处就是，如果主方法要show一下对象的信息，那么有几个不同的类的对象，就要些多少个不同类的对象的show的静态方法，因为要传递参数，
    如果有Cat, Dog,Snake ,那么要一个个写出来，耦合度很高，如果通过继承，那么就可以实现！
   一	个show，调用多个不同类的show！
    
  
	
}
 		
 	（四）抽象方法	
 		 
 		 4.1 为什么定义抽象方法
 		 当类的某个操作无法具体实现时候，就可以把该操作定义为抽象方法
 		 抽象方法使用abstract修饰，只有方法的声明，没有方法体
 		 4.2 为什么定义抽象类
 		 		含有抽象方法的类定义为抽象类
 		 		对事物进行更高层级的抽象类，就会形成抽象类
 		 4.3抽象类的特点
 		 		1）使用abstract修饰的类就是抽象类，抽象类中可以没有抽象方法，但是含有抽象方法的类必须定义为
 		 		抽象类
 				2）子类继承了抽象类，必须重写抽象类的抽象方法，如果子类没有重写所有的抽象方法，
 				则子类也需要定义为抽象类
 				3）抽象类不能实例化对象，抽象类的引用需要赋值子类对象，或者赋值匿名内部对象
				4）抽象类虽然不能实例化对象，但是肯定含有构造方法，普通类的所有成员都可以
				在抽象类中定义，子类创建对象，先调用父类的构造方法，所以抽象类当中肯定有构造方法
				5）abstract与final 不可以一起使用
				因为 final 代表最终的  abstract 修饰的是要被继承的，所以不是最终类

注意：    //抽象类的引用可以赋值匿名内部类对象

        // 抽象类引用赋值子类对象时，需要先定义一个子类，再通过子类创建对象给抽
        		象类引用赋值，如果该就使用一次
        		      b1 = new Bird() {
            @Override
            public void power() {
                System.out.println("黄色鸟会分身");
            }
        };
        只使用一次 同时也意味着只能用一次，通过这种方式override 就不用去定义一个黄色小鸟power的方法
        而是直接用这种方法  通过实例化 抽象类的重新写（原本是不可以直接实例化抽象类），
        也是因为由于抽象类的所有方法都必须要重写，复写，所以这种上面的语句就实现了重写，就可以暂时定义出来了
        
        //在程序中的其他地方没有再使用该子类，这种情况下，就不需要单独定义一个
        		子类了，可以直接给抽象类引用赋值匿名内部类对象 
        
  （五）接口
  		5.1接口的定义与实现
  			 计算机中有那些接口？
  			 		USB 电源 ，网线 耳机 HDMI接口。。。。。
  			 计算机接口的作用？
  			 		通过接口连接更多的外设，扩展了计算机的功能
  		而java中的接口可以理解为功能的封装，通过接口来扩展类的功能
  			怎么定义接口？
  					[修饰符] interfacec 接口名{
  						功能使用方法表示，接口中的方法默认使用 pulibc abstract 修饰
  						
  					}
  					
  		实现接口？
  				class 类名 implements 接口名{
  					类实现了接口，需要重写接口的抽象方法
  				}
  		
  		
  		
  5.2 接口多态
  		接口是一种引用数据类型，引用类型有：接口，数组，枚举，注解
  		但是接口不能实例化对象，接口引用赋值实现类对象或者匿名内部对象
  		通过接口引用抽象方法，实际执行的时实现类对象类的方法，这就是接口多态
  		
  		经常把接口引用作为方法形参，在调用方法时传递各种实现对象
  		
  5.3 接口种的内容：
  			1）接口中的方法默认使用 public abstract 修饰，可以不写，默认
  			2）接口中的字段默认使用 public static final 修饰 
				在JDK8中，对接口做了改进：
						3）接口中可以定义static 静态方法
						4）可以定义default修饰的方法
						
	5.4 接口说明
			1）接口可以理解为功能的封装
			2）类实现了接口，需要重写接口中的抽象方法，如果没有重写接口抽象方法，则
				此类需要定义为抽象类
			3）接口是引用数据类型，但是不可以实例化对象，接口引用需要赋值实现类对象，或者
			赋值匿名内部类对象
			4）接口引用调用抽象方法，实际执行时调用类对象的方法，称为接口多态，如果没有多态接口就没有意义
			5）接口中方法默认使用public abstract ，接口中字段，默认 public static final 修饰
					JDK8中又增加了static /default 修饰的方法，接口内又这4部分内容
				6）接口也可以继承，接口也支持多继承，类只支持单继承
			7）一个类可以实现多个接口，但只能支持单继承，接口与接口之间使用, 
			
			
5.5 接口和抽象类的区别
	相同点：
		1）定义抽象方法
		2）都不能实例化对象
		
		
	不同点:
		1）意义不一样:
			接口是功能的封装，抽象类是对事物更高级层级的抽象
		2）定义不同
			接口使用interface 定义
			抽象类使用 abstract class 定义
		3)内容不同 
				接口中只有四部分：
				抽象类除了抽象方法，还有普通类的构造方法，实例变量，实例方法，静态成员都可以定义
		4）使用方式不同
				接口需要被实现，接口允许多继承
				抽象类需要被继承，只支持单继承
		5）应用场景不同
				如果情景时为了扩展功能，优先选择接口
				如果出了扩展功能外，还需要保存不同数据，选择抽象类
				抽象类的抽象方法，需要在子类重写，抽象类可以约束所有子类都具有某个相同的功能，起到模板作用
		
		6）接口和抽象类如何选择？
				1）接口是功能的封装，
				2）抽象类是对事物进行抽象
			
				
				
	5.6 接口的应用
			1.接口可以用来封装某些功能
				接口表示对象的一种能力，或者一个操作
			2.接口也可以看作是一个操作协议
			3.接口在某种程度上，可以解决类的多继承问题
			//例如 定义 学生类， 工人类， 那么打工的学生 就因为类不能多继承，所以不可以同时继承学生和工人
 
			// 解决办法： 打工的学生 继承学生，然后实现工作接口
	5.7 提倡面向接口的编程
			1.接口比较灵活，一个类在继承一个父类的时候，可以实现多个几口
			想让某个对象具有什么能力，就让类实现什么接口
			
			2.面向抽象编程程序更容易扩展，降低类之间的耦合度
				经常吧接口引用作为方法的形参，在调用时传递各种实现类对象
			
			3.接口可以使项目分层
				如 先制定了USB通讯协议，电脑厂商根据USB协议生成电脑（它有USB插槽），
				各种USB设备根据USB协议生产带有USB插头的设备	
				
	（六）类与类之间的关系
	
			6.1 UML，统一建模语言，用于分析/设计阶段，通过一些图形化模型对项目进行解释说明
				RationalRose工具
				Viso
				Star UML  
		6.2关系
				1）继承关系（泛化）
						子类继承父类，子接口继承父接口
				
				2）实现关系
						类实现接口
				

				3）依赖关系
					如果在A类中方法的返回值类型，参数类型，局部变量类型使用B类定义的，称A类依赖B类
					
					
									
				4）关联关系
					如果A类中使用了B类定义了成员变量，称A类关联B类
					
				
				5）聚合关系
					
					聚合是关联的一种，如果A类由若干B类组成，但A类不能决定B类的声明周期，就称
					A类是聚合类
					
				
				6）组合关系
					组合是关联的一种，如果A类由若干B类组成，并且A类能决定B类的生命周期，称A为组合类
					
					以上六种关系在RationalRose 中有做笔记
					
				7）is a   继承关系 当子类 is a 父类时，才能使用继承
					like a 	实现关系  
					has a   关联关系
						
		
		 	
===================================================================================
二、常用类
	（一）	字符串相关类
												位置num	0 1 2 3 4 5 6 。。。。。
		有一点需要注意的是  数组	 [a b c d e f g .......      ]
		 String data[];
		 data[0]  是表示第一个位置的值
		 基本有关数组 [] 里面的   [num]--->表示 第num+1个数值 。第num+1个位置的值
		 [6 - 10)
		 表示 第 7 8 9 10 个数值 
						 1 9 9 7	
		 		440681 1997
		 
			1.1 String //要熟练掌握
			一般来说 通过String类的构造方法，把其他类型转换成String， 而通过 其他类型的方法，把String类型转换成特定类型
					1)如何创建对象
					
					

        //1)给String对象赋值字符串 字面量
        String s1 ="hello";

        //2)String（）
   
        String s2 = new String();
        System.out.println(s2==null);//false  
        System.out.println(s2.length());//0 长度为0的字符串  相当于 "" 里面没有任何字符

        //3）根据字节数组创建String对象，String（byte[])
        String(byte[] bytes) 
				通过使用平台的默认字符集解码指定的字节数组来构造新的 String
				
        byte [] bytes = {65 , 66 , 67 ,68 };
        String s3 = new String(bytes);
        //把这个数组中，所有的字节 都转换为字符串
        System.out.println(s3);//ABCD
        
        
        s3 = new String(bytes, 0, 3);//把 bytes 数组中从0开始的3个字节转换为字符串
        System.out.println(s3);//ABC
        //在开发中，字节数组中的字节能是从网络中获得的01序列

        String text = "hello lili 你真棒";
        byte [] bytes1 = text.getBytes();//把text的字符串以当前默认的编码（UTF-8)转换为字节数组
        //或者 定义出来再 赋值都可以
        System.out.println(bytes1);//[B@2d98a335
        System.out.println(Arrays.toString(bytes1));//[104, 101, 108, 108, 111, 32, 108, 105, 108, 105]
        //                                           英文一个字节，汉字3个字节

        //4)根据字符数组创建字符串对象，String (char[])
        // 字符---》字符串
        //char []  ---> String
        //方法类似 byte[]---> String   ，都是 new String(要转换的引用类型-数组);
        char [] chars = {'A','b','c','北'};
        String s4 = new String(chars);// 把 chars 字符数组中 所有字符都抓换为字符串
        System.out.println(s4);//Abc北
        s4 = new String(chars, 0, 2);
        //比上面转换得语句多了 始  终
        
        System.out.println(s4);//A b 从 0 开始的 2个 字符

        // 字符串----》字符数组
        //    等号左边：字符数组 =    等号右边：字符串. tochararry 变成 char类型的排列
        chars = text.toCharArray();
        System.out.println(chars);	// hello lili 你真棒 字符数组排列出来就是这样 相当于 String，因为字符组合嘛
        System.out.println(Arrays.toString(chars));//把字符数组每一个元素一个个列举出来
        因为这里利用了Array.toString 所以会形成数组形式 列举出来
        而 如果转换成byte类型的数组排列方式，那就要Arraytostring,因为如果直接打印，直接放在一起没有意义，65666768这样的样子，所以他会打印
        出 这个byte 数组的地址
        //  [h, e, l, l, o,  , l, i, l, i,  , 你, 真, 棒]

        //5)根据已有的String 创建新的Sting
        String(String original) 
				//初始化新创建的String对象，使其表示与参数相同的字符序列; 
				//换句话说，新创建的字符串是参数字符串的副本。 
        String s5 = new String(text);
        System.out.println(s5);// hello lili
        System.out.println(text);// hello lili
        System.out.println(s5==text);//false 因为地址不一样

        System.out.println(s5.equals(text));//字符串比较用 equals

        System.out.println("=======================================================================");
        //6)字符串以指定的编码转换为字节数组  text: hello lili 你真棒
        // 字符串----》字节数组  （以UTF-8）
        bytes = text.getBytes();    //以默认编码(UTF-8)转换为字节数组
        System.out.println(Arrays.toString(bytes));
        //[104, 101, 108, 108, 111, 32, 108, 105, 108, 105, 32, -28, -67, -96, -25, -100, -97, -26, -93, -110]
        // H   E     L    L    O    空格  l   i      l   i  [ ] [    你      ]  [ 真          ]   [    棒        ]
	//上面把 字符串--字节数组
	
	//这里又把字节数组转换成字符串
        String s6 = new String(bytes);
        System.out.println(s6); // ===》 等于 System.out.println(text);
        
        //把bytes 以指定编码形式转换称字符串
        s6 = new String(bytes,"GBK");//把bytes数组中的字节 以GBK编码转换为 字符串
        System.out.println("下面是以GBK的编码转换");
        System.out.println(s6);//hello lili 浣犵湡妫�   中文已经不一样了，因为 UTF-8和GBK 中文的字节不一样

				//把字符串通过调用getBytes方法 ，并且指定GBK编码形式转换称字节数组
        bytes = text.getBytes("GBK");//这里直接写会报错，按 alt+enter--》add。。。 与抛出有关
        //在GBK中，一个英文还是一个字节，一个中文 2个字节
        System.out.println(Arrays.toString(bytes));
        //[104, 101, 108, 108, 111, 32, 108, 105, 108, 105, 32, -60, -29, -43, -26, -80, -12]

       
    }
}

				2）String 有哪些方法
						1.char   charAt（int index）  返回字符串中 index索引位置的字符
						
						2.int    comparetTo(String anotherString) 当前字符串与参数字符串比较大小
										比较规则： 如果当前字符串大，返回正整数，否则返回负整数
													逐个逐个对应的比较，遇到不同的相减
						
						3.int compareToignoreCase(String str) 忽略大小写的比较
						

					
						4. boolean endsWith（String suffix）  判断 字符串是否以 suffix 结尾				
						5. boolean equals(Object anObject) 判断当前字符串与参数字符是否一样
						6. boolean equals(String anotherString) 忽略大小写
						
						
						7.byte[] getBytes() 
								使用平台的默认字符集将此 String编码为字节序列，将结果存储到新的字节数组中。  
							byte[] getBytes(Charset charset) 
								使用给定的charset将该String编码为字节序列，将结果存储到新的字节数组中。  
						8.
						int hashCode()   返回此字符串的哈希码。  
						
						int indexOf(int ch) 	返回指定字符第一次出现的字符串内的索引。  
						
						int indexOf(int ch, int fromIndex) 
							返回指定字符第一次出现的字符串内的索引，以指定的索引开始搜索。
						String substring(int index1  , int index2 )  
						 返回指定字符串中  index1与index2索引之间的字符串内容，不包括index2
						 如果index2 即第二个索引不填，默认是到最后
							
					  //9） indexOf(ch)                    LastIndexOf(String)          substring()
        //     索引XX第一次出现的位置num          索引XXX最后出现         根据()形参表示 从X索引--X索引  的字符串内容
        String path = "D:\\IDEA-workplace\\Day01\\src\\com\\bjpowernode\\StringClass\day\\Test01.java";
        int lastSlash = path.lastIndexOf('\\');//索引 最后一个 \    代码用\\表示\ 第一个\是转义  索引返回字符串数组所在的位置
        int dotIndex = path.indexOf('.');//这里indexof 的参数类型是 （int ch）下面是理解 ///索引第一个.  返回值是 字符串数组 . 所在第几个位置
//        int s5 = 's';//类型转换 //结果是115   s的编码是 115
//        char s6 = 's';
//        System.out.println("==============");
//        System.out.println(s5);
//        System.out.println(s6);//s
        String folder = path.substring(0, lastSlash);//文件夹名
        //     \\ 表示 字符 \  因为单个反斜杠有转义功能
        String filename = path.substring(lastSlash+1, dotIndex);//取"\"下一个索引 即 [T  到 dotIndex 索引'.'  开区间 ---->  [T  .) 所以就是 文件名
        String suffix = path.substring(dotIndex);
        System.out.println(folder);//D:\IDEA-workplace\Day01\src\com\bjpowernode\StringClass\day  文件夹名
        System.out.println(filename);//Test01   文件名
        System.out.println(suffix);//.java suffix  扩展名
        
        		
							
							
							
							
						9.boolean isEmpty()  返回 true如果，且仅当 length()为 0 。 	
			
			
					10.int lastIndexOf(int ch) 
						返回指定字符的最后一次出现的字符串中的索引。  
					int lastIndexOf(int ch, int fromIndex) 
						返回指定字符的最后一次出现的字符串中的索引，从指定的索引开始向后搜索。  
					int lastIndexOf(String str) 
						返回指定子字符串最后一次出现的字符串中的索引。  



					11.boolean matches(String regex) 
告诉这个字符串是否匹配给定的 regular expression 。  

				 	12.String replaceAll(String regex, String replacement) 
用给定的替换替换与给定的 regular expression匹配的此字符串的每个子字符串。  
String replaceFirst(String regex, String replacement) 
用给定的替换替换与给定的 regular expression匹配的此字符串的第一个子字符串。  
String[] split(String regex) 
将此字符串分割为给定的 regular expression的匹配。  
String[] split(String regex, int limit) 
将这个字符串拆分为给定的 regular expression的匹配。  

				13.CharSequence subSequence(int beginIndex, int endIndex) 
返回一个字符序列，该序列是该序列的子序列。  



			14.static String valueOf(boolean b) 
返回 boolean参数的字符串 boolean形式。  
			
	15.String 正则表达式
 /*
 * String 中 与 正 则.. 表达式相关的方法
 *      正则表达式就是一个模式串,用于判断字符串是否匹配指定的模式
 *              [abc]     匹配 a,b,c中的一个
 *                .         任意字符                如果要表示 实际的.  --->  \\.
 *                \d        数字
 *                \s        空白符
 *                \w        单词字符: [a-z  A-Z 0-9]
 *                X?        匹配X一次或0次	
 *                X*        匹配X任意一次
 *                X+        匹配X至少一次
 *                X{n}      匹配n次
 *                X{n,}     匹配至少n次
 *                X{n,m}    匹配至少n次,至多m次
 *                (   |   )        分组
 * Author pwj
 */
 在其他语言中，\\ 表示：我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。

在 Java 中，\\ 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。
在其他的语言中（如Perl），一个反斜杠 \ 就足以具有转义的作用，
而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用
 						String email;
   定义模式	String pattern = "\\w{6,}@\\w{2,}\\.(com|cn|net)";
            email.matches(pattern)  通过调用字符串的matches方法 把字符串模式引入，判断正误
						            
            	
             //2)replaceAll()替换
            String text = "小明123asdasd13小于";
            System.out.println(text.replaceAll("\\d","*"));//小明***asdasd**小于
        //把字符串 所有的\\d (数字),用 * 表示

            System.out.println(text.replaceAll("\\w", "*"));//小明***********小于
//            把所有 字符 数字都替换


        //3)split()分隔  split(String regex) regex 正则表达式
        //将此字符串分割为给定的 regular expression的匹配。
        text = "A small step forward  ,   A big step of civilization! ";
        System.out.println(text);
        String []   split = text.split("[\\s!,]+");
        //()里面是正则表达式  [abc]  \\s ! , 三个中的一个,split 会把字符串里面 的含有刚才三个中的用,表示,分割开
        // +号代表 至少一次
        至少一次意思，入 \\s+ 表示 遇到一个空格或一个空格以上，匹配给你一个，  如果没遇到不匹配
        System.out.println(Arrays.toString(split));//[A, small, step, forward, A, big, step, of, civilization]

            
   16. 字符串字面值判断
    String s1 = "hello";
        String s2 = "hello";
        System.out.println(s1.equals(s2));//true
        System.out.println(s1==s2);//true
        /*
        关系运算符 ,判断s1 和s2变量的值是否一样
        运行结果为true,说明s1和s2引用了同一个对象
        在java中,所有双引号引起来的字符串字面值都存储在字符串常量池中,
        执行s1=="hello"时,系统会把"hello"自负床字面值存储到常量池中,
        再执行s2 = "hello"时,系统回直接把常量池中"hello"对象的引用赋值给s2,所以 s1和s2都引用引用常量池中同一个字符串常量"hello"
         */
         
    17./**
 * String 字符串对象是不可变的
 * String s1 = "hello";
        s1 = "world";
        /*
        在执行s1="hello"   是把字符串常量池中的"hello"字符串对象的引用保存到s1中,
        s1准确的说称为对象的引用,保存的是对象的地址,"hello"才是字符串的对象
        String 对象不可变,是指 不能,也不可能把hello 变为 "wolrd"
        执行 s1 = "world" 时,常量池新添加一个"wolrd"对象,把该对象的引用赋值给s1 .其实就是把world对象的地址赋值给s1,s1引用指向"world"而已
        String 中的toUpperCase(),toLowerCase(),trim(),replaceAll(),等方法,都是放回一个新的字符串,原来的没有变
        每一次进行字符串连接都会生成新的字符串对象
         */
        s1 = " ";
        for(int i = 0; i<10 ;i++){
            s1 = s1 + i;//在运行过程中, value值不断的发生变化,是因为字符串在连接时,因为有变量,所以字符串地址不停的发生变化(即 不断的有新的对象出来,原来的字符串对象就释放了)
        }
        System.out.println(s1);  // " "0123456789
        //以下两行共创建了多少个String 对象  //3个 hehe   s2 s3   两个"hehe"是一样的 引用的是同一个对象的地址
        String s2 = new String("hehe");
        String s3 = new String("hehe");
        //以下两行共创建多少个String对象  // 3个
        s2 = "yngying";  //1个
        s3 = "ying "+"ying"+"ying"+ s2; //系统会优化为 "yingyingying"+s2  //前面一个 ,总的又算一个

        //总 2个
        s2 = "hei";//一个
        s3 = s2+"hei"+"hei"+"hei";//前面有变量不优化,在+连接过程中不会创建String对象 
 */     
          
            
			
			
			
	1.2	StringBuilder/StringBuffer
			
			 StringBuilder/StringBuffer
 *      1)称为可变的字符串
 *      2)最常用的方法是append()
 *      3)StringBuilder 不是线程安全,而StringBuffer是线程安全的 如果是开发多线程程序,用后者 否则前者,StringBUilder的效率比后者快
 *      4)StringBuilder/StringBuffer默认初始化容量:16
 *      5)扩容:valu.length*2 +2  两倍+2   记住
 
     如果多次连接时候，调用String类的 append 方法  
     String append(i));
			
			
			
			
	
	
	（二）	日期相关类
				2.3.1 Date 类
						java.util.Date类 
								Date date1 = new Date();//返回当前日期
	
								
				2.3.2 LocalDateTimeLe类
						从JDK8中，增加了java.time包，定义了一组线程安全的日期时间类，
						LocalDateTime datetime = LocalDateTime.now();
						格式化：  
						DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
						String text = datetime.format(formatter);
						
						String str = "2020年11月12日 08:22:22";
							DateTimeFormatter formatter1 = DateTimeFormatter.ofPattern("yyyy年MM月dd日 HH:mm:ss");
						datetime = LocalDatetime.parse(text , formatter1);
						//
		  //1)创建一个日期对象，返回当前日期与时间

        Date date = new Date();
        System.out.println(date);
        //Sun Nov 24 10:07:08 CST 2019

        //2)获得当前日期距离 1970-1-1 00：00经过的毫秒数
        long millis = System.currentTimeMillis();
        System.out.println(millis);

        //3)创建date对象时，可以通过构造方法参数指定距离1970-1-1 00：00 经过的毫秒数
        Date date1 = new Date(millis+1000*60*10);//10分钟后的时间
        System.out.println(date1);
        
        //4）使用 simpleDateformate，可以把日期转换成指定的格式，在构造方法中指定日期格式串
        //以下是定义转换日期的格式串

        SimpleDateFormat s = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");//规定这样写最好 通过simpledateformate的构造方法 把date转换指定格式String
       //调用 方法中的formate 把 date对象转换为字符串
        String text = s.format(date1);
        System.out.println(text);
//
        //5）把代表日期的字符串转换为Date对象
        System.out.println("=========");
        text = "2088-10-12-8:22:22";
        SimpleDateFormat s2 = new SimpleDateFormat("yyyy-MM-dd-HH:mm:ss");
        //会按照pattern  对text 的字符串进行一一转换           2088  oct  12  08:22:22  年月日这些事text本身就有的  是方法调用时转换的根据
        date = s2.parse(text);//把字符串转换为date   但是报错 因为 如果字符串与格式串不匹配就会转换异常
        System.out.println(date);//date对象  默认格式 Tue Oct 12 08:22:22 CST 2088
        System.out.println(s2.format(date));//通过构造方法的foramat实例方法把date对象 按照指定日期格式串转换为字符串
        System.out.println(s2.format(s2.parse(text)));//和上面的语句一样，只是把date 写成 s2.parse(text)
        //s2.parse()表示 调用 s2的parse实例方法，按照指定的字符串格式把字符串改成默认格式  parse
        //即默认---》指定
        // Date--》指定模式
        Date date2 = new Date(1000*60*10);//返回 1970 01月01日 + 10mins(1000*60*10毫秒)
        System.out.println(date2);//Thu Jan 01 08:10:00 CST 1970

	总结：
				Date 类型 ---》 指定格式的字符串 
				1.定义了Date对象，定义SimpleDateFormat 格式
				2.调用格式的.format方法，实参是date  返回值是一个 string！
				搞定收工
				
				指定格式的字符串----》Date类型
				1.定义一个日期字符串，
				2.定义以个SimpleDateFormat  数字改成 yyyy   MM dd  HH:mm:ss 
				例如："yyyy-MM-dd-HH:mm:ss"  - 是因为上面的字符串是用-来连接，  ：也是因为上面的时间是用：连接  
				数字改成字母区分
				
				最后调用用一个Date类型来接受 格式的.parse方法，实参是字符串 ，返回时一个date类型
	
	
	
	（三）	数学相关的类
			3.1 Math类
				java.lang.Math类  类中定义了一组与数学函数相关的操作
					
			3.2 BigDecimal
				java.math.BigInteger java.math.BigDecimal 
				
			3.3 Random
				用于产生随机数
			
		（四）包装类
				java为每种基本类型都提供了对应的包装类
					基本类型                包装类
					byte										Byte
					short										Short
					int											Integer
					long										Long
					float										Float
					double									Double
					boolean									Boolean	
					char										Character
					
		为什么提供包装类
					为了编写方便 
					（Object obj)  
					
		如何用？
				创建包装类对象
				 //1)所有的包装类都可以根据基本类型创建包装类对象
        byte bb = 123;
//        Byte b1 = new Byte(10);//报错
        Byte b1 = new Byte(bb);/形参可以选择String 或 byte  直接给 10  123 是整型
        Byte b2 = new Byte((byte)10);
        Integer i1 = new Integer(123123);
        Double d1 = new Double(21.1);
        Boolean flag = new Boolean(true);
        Character c1 = new Character((char)10);


        //2)除了Character 外,其他的包装类可以通过String形参字符串创建包装类对象

        Integer i2 = new Integer(123);
        i2 =  new Integer("12a3");//编译没错 运行报错
        //n thread "main" java.lang.NumberFormatException: For input string: "asd"
        //字符串没错 但是里面一定要数字 不能是其他  否则报错
//        System.out.println()
        Double d2 = new Double("123");
        System.out.println(d2);//123.0
        d2 = new Double(123.2);//
        System.out.println(d2);//123.2    语法规则一样,编译可以 ,但是如果 字符串里面不是全数字 或.  含有字母的话就报错
        d2 = new Double("1e+2");// 23e+2==23*10^2
        System.out.println(d2);

        Boolean  b3 = new Boolean("true");
        System.out.println(b3);//true
        b3 = new Boolean("asds");
        System.out.println(b3);//false
        //Boolean包装类 创建对象如果形参是String 那么会把除"True"外的字符串转换为 false

        //3)所有的包装类都有TYPE字段,表示基本类型
        System.out.println(Integer.TYPE);//int
        System.out.println(Character.TYPE);//char
        System.out.println(Double.TYPE);//double
        System.out.println(Boolean.TYPE);//boolean

        //数值类型都有最大值和最小值
        System.out.println(Integer.MAX_VALUE);
        System.out.println(Integer.MIN_VALUE);

			包装类的常用操作
				  Integer i1 = new Integer(128); // byte  -128- 127   0-127- -128 -0
        Integer i2 = new Integer(1456);


        //1)从num类继承的方法,可以把包装类对象转换为其他的基本类型数据
					包装类对象.xxxValue（）方法
        //通过 包装类对象的实例方法
        System.out.println("=========");
        System.out.println(i1);
        int num = i1.intValue();//128
        System.out.println(num);
        double dd =i1.doubleValue();
        byte bb = i1.byteValue();//-128-127
        System.out.println(num+"\t"+bb+"\t"+dd);


        //2)compare(int x,int  y )比较两个int 类型数据的大小
        System.out.println(Integer.compare(20, 10));// 1   如果第一个数比第二个数大 ,就返回1
        System.out.println(Integer.compare(20, 100));// -1   如果第一个数比第二个数大 ,就返回1
        //如果相等,返回0

        System.out.println(Double.compare(10, 21.1)); //-1

        //3)包装类都实现了comparable 接口,重写了 compareTo()方法

        System.out.println(i1.compareTo(i2)); // 比较的是 对象里面的值  如果 前者大  1  参数大 就 -1
        Double d1 = new Double(21.2);
        Double d2 = new Double("20");
        System.out.println(d1.compareTo(d2)); //1
			即 如果 定义了两个 包装类，通过.compareTo方法可以比较大小
				而如果直接比较任意两个和包装类无关（除了类型），可以直接包装类.compare（xx,xx）方法

        //4)包装类重写了 equals方法
        System.out.println(i1.equals(i2));//false   因为 返回值是 Boolean 而不是-1


        //5)max(),min()
        System.out.println(Integer.max(12, 123));//123  返回最大值

        //6)重点: 包装类有把字符串转换为 int 类型的方法 parseInt(String s)
        String text = "256";
        System.out.println(Integer.parseInt(text));//把字符串转换为int类型

        double d3 = Double.parseDouble("123.2");//把字符串转换为小数
        System.out.println(d3);

        //7)Integer 可以把整数转为二进制,八进制,十六进制
        System.out.println(Integer.toHexString(100));//64 16进制
        System.out.println(Integer.toOctalString(100));//144
        System.out.println(Integer.toBinaryString(100));//110100



        //8)valueOf()可以把基本类型,字符串转换为包装类对象
        i1 = Integer.valueOf(456);
        i2 = Integer.valueOf("78");
        System.out.println(i1);
        
        
   装箱
 *      把基本类型数据转换为包装类对象
 *
 *  拆箱
 *      把包装类对象转换为基本类型
 *    java可以自动进行装箱与拆箱
     	   
        
       Integer i1 = 123 ;//装箱  右边是 int  左边是对象 所以叫装箱 因为把int 放进对象里
        int num = i1 ;//拆箱   右边是 对象 左边是 int

        Integer i2 = 456;//系统根据 456 基本数据类型 创建一个包装类对象,把该对象的引用赋值给i2
        Integer i3 = 456 ;//系统根据 456 基本数据类型 创建一个包装类对象,把该对象的引用赋值给i3
        System.out.println(i2==i3);//false


        Integer i4 = 99;
        Integer i5 =99 ;
        System.out.println(i4==i5);//true

        /*
            Java 认为 -128-127之间的整数使用比较频繁,这个范围内的整数装箱后存储到共享池中,采用享用模式
            i4 == 99 ;  系统创建一个包装类对象存储共享池中
            再执行 i5= 99 ,系统直接把共享池中对象的包装类对象的引用,赋值给i5
            所以 i4 和i5都引用了同一个包装类对象

         */


        Long gg1 = 88l;//长整型包装
        Long gg2 = 88l;
        System.out.println(gg1==gg2);//true
        //-128-127整数 如果相同就会出现共享 ,否则 各自单独引用
        // 虽然字面值相同,但是地址不同



			
				
		
	（五）集合 

			集合是用来存储引用类型数据的容器
				注意：集合只能存储引用类型数据，不能存储基本类型
			集合分为两大类：
					Collection 集合 ：单个存储
					Map 集合 ：是按<键，值>对 的形式存储数据  <员工姓名，工资>
					
					
			
			java.util.Collection		
	5.2 Collection基本操作
			
		boolean add(E e)      确保此集合包含指定的元素（可选操作）。  
		

		boolean addAll(Collection<? extends E> c)  
		将指定集合中的所有元素添加到此集合（可选操作）。  


		void clear() 
		从此集合中删除所有元素（可选操作）。  
		
		
		boolean contains(Object o) 
 		如果此集合包含指定的元素，则返回 true 。  

		boolean containsAll(Collection<?> c) 
		如果此集合包含指定 集合中的所有元素，则返回true。  
		
		boolean equals(Object o) 

		将指定的对象与此集合进行比较以获得相等性。  
		
		int hashCode() 
		返回此集合的哈希码值。  
		
		boolean isEmpty() 
		如果此集合不包含元素，则返回 true 。
		  
		Iterator<E> iterator() 
		返回此集合中的元素的迭代器。  
		
		boolean remove(Object o) 
		从该集合中删除指定元素的单个实例（如果存在）（可选操作）。  
		
		int size() 
		返回此集合中的元素数。  
		 
		Object[] toArray()   
		返回一个包含此集合中所有元素的数组。  
		  **
 *  演示Collection基本操作
 * Author pwj
 */
public class Test01 {
    public static void main(String[]args){

        //1)定义一个Collection集合
        //Collection是一个接口

        Collection collection = new ArrayList();


        //2)向集合中添加元素
        collection.add("hehe");
        collection.add("abc");
        collection.add("helo");
        collection.add(123);//系统会先把基本类型装箱为包装类对象，再添加到集合中
        collection.add(true);

        //3）打印  collection接口引用，实际引用的ArrayList对象 打印时调用的是ArrayList对象的toString
        System.out.println(collection);//[hehe, abc, helo, 123, true]

        //4)判断

        System.out.println(collection.isEmpty());//false
        System.out.println(collection.size());//5
        System.out.println(collection.contains("abc"));//true


        //5)删除

        collection.remove("abc");//删除
        System.out.println(collection.contains("abc"));//false

//        //6)清空
//
//        collection.clear();
//        System.out.println(collection);//[] 清空了

        //7）使用增强的 for循环遍历

        for(Object object : collection)
        {
            System.out.println(object);
        }


/**
 * 集合泛型与迭代
 * Author pwj
 */
public class Test02 {
    public static void main(String[]args){
        //一般情况下，在集合中存储同一类型的数据
        //在定义集合时，可以通过泛型指定集合中存储元素的类型
//泛型就是把数据类型作为参数传递，在collection后面 使用 <>  指定集合中存储 String 类型的字符串
         Collection<String> collection = new ArrayList<>();

         //向集合中添加数据时，只能添加String 字符串，语法错误
        collection.add("s");
        collection.add("pwj");
        collection.add("ps");
        collection.add("pwj");
        collection.add("ps");
        collection.add("pwj");
        collection.add("ps");

//        collection.add(123);//添加数据时，系统会进行数据类型检查，这就是泛型的好处
        System.out.println(collection);

        //2)所有的colleciont集合都有 iterator的方法  ，该方法返回一个 Iterator迭代器

        //ctrl + alt + v 可以把表达式赋值给一个局部变量
        Iterator<String> iterator = collection.iterator();

        /*
        调用iterator（）方法，返回了集合的迭代器，迭代器有一个cursor 游标
        相当于指针，刚刚获得迭代器时，游标指向第一个元素的前面

        hashNext()方法判断游标后面是否还有没访问的元素，
        next（）方法把游标后面的元素返回，然后游标下移

         */
        while(iterator.hasNext()){
            String next = iterator.next();
            System.out.println(next);
        }
        //注意循环完以后，当前iterator的游标指向最后一个元素的后面了，这个iterator迭代器不能再用了
        //注意循环完以后，当前iterator的游标指向最后一个元素的后面了，这个iterator迭代器不能再用了

        //4）remove（o） 只删除 集合中第一个匹配的元素
        collection.remove("pwj");
        System.out.println(collection);//[s, ps, pwj, ps]把 第一个匹配到的


        //需求：删除集合中所有的ps

        //遍历集合中所有的元素,如果是“ps” 就删除 ，通过 迭代删除
        //但是刚才的迭代器已经是指向最后一个元素的后面，需要重新获得迭代器

        //所以再调用一次 iterator（）方法，返回一个新的
        iterator = collection.iterator();

        while(iterator.hasNext()){
            String s = iterator.next();
            if("ps".equals(s)){//这里用 "ps"==s 也可以  字符串存储在方法区的，如果相同 应该是调用同一个引用
                iterator.remove();//迭代删除  是通过迭代器来删除 而不是 collection.remove()
//                collection.remove(s);  编译报错
            }
        }
        System.out.println(collection);//[s, pwj, pwj]
        
        
        
          //String Date  Collection 这些操作一定发给要熟练掌握 反复的写  ******
  		
  List 集合 
  		1) List继承了Collection  ，Collection所有的操作，List都可以继承
  		2) List特点
  				有序，存储的顺序就是添加的顺序
  				可重复，可以存储重复的数据
  		3) List为每个元素指定了一个索引值，增加了针对索引值的操作
  				
  		
        //1)定义List集合，存储String
        List<String> list = new ArrayList<>();
        //

        //2)添加元素
        list.add("LILI");
        list.add("pwj");
        list.add("LILI");
        list.add("pwj");
        list.add("pwj");

        //3）直接打印  存储顺序就是添加顺序 可以添加重复的数据
        System.out.println(list);//[LILI, pwj, LILI, pwj, pwj]
        //print 执行时，把list 的地址 即 new Arraylist对象地址赋值给 Objetct  然后会 执行 String.valueOf(x)    ---》 obj.toString（） 实际执行的是
                                                                                                        //  Arraylist的toString方法
        // 而且 Arraylist 没有直接重写toString  方法，是 它的 父类 的 父类重写了


        //4）判断
        System.out.println(list.size());//5
        System.out.println(list.isEmpty());//flase
        System.out.println(list.contains("pwj"));//true
        System.out.println(list.contains("LILI"));//true

        //List 的迭代
        Iterator<String> iterator = list.iterator();
        while(iterator.hasNext()){
            String next = iterator.next();
            System.out.println(next);
        }


        System.out.println("===delete====");
        //6）删除
        //删除第一个 ，原理和 Collection一样
        list.remove("pwj");
        System.out.println(list);

        System.out.println("=====7)======");
        System.out.println(list);
        System.out.println("list的长度为"+list.size());
        //7）
        //List为每个元素指定了一个索引值，增加了针对索引值的操作
        //  注意索引值不能越界
        list.add(0, "xx");//在第一个位置
        System.out.println(list);//[xx, LILI, LILI, pwj, pwj]
        System.out.println("list的长度为"+list.size());
        list.add(list.size(), "xx");// size = 5  ---》索引值=5 所以 在第六个位置+  即最后pwj后面加xx
        System.out.println(list);
        //但是 直接 list.add("xx"),就表示了再最后加
//        list.add(10, "xx");
//        System.out.println(list);//报错 a.lang.IndexOutOfBoundsException: Index: 10, Size: 5

java中length,length(),size()区别

java中的length属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了length这个属性.
java中的length()方法是针对字符串String说的,如果想看这个字符串的长度则用到length()这个方法.
java中的size()方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!

        list.remove(0);//把索引值为0的元素删去
        System.out.println(list);//[LILI, LILI, pwj, pwj, xx]

        System.out.println(list.get(0));
        System.out.println(list.get(1));
        System.out.println(list.get(2));
        System.out.println(list.get(3));
        System.out.println("通过for增项循环来输出");
        for(String s : list){
            System.out.println(s);
        }
        System.out.println("通过普通for循环来输出");
        for(int i = 0 ; i<list.size();i++){
            System.out.println(list.get(i));
        }

        list.set(0, "ss");
        System.out.println(list.get(0));//把 索引值为 0 的 元素 所保存的值改为 ss
     
   1.  
     /**
 *
 * Arraylist集合，在contain（o）,remove(o),操作时，需要比较集合中的元素与指定的元素o 是否一样，就会调用
 * 对象的equals（）方法
 * 即在list集合中，如果存储自定义类型数据，那么就需要重写equals/hashcode（）方法
 * Author pwj
 */
public class Test02 {
    public static void main(String[]args){
        //1)定义一个List集合 存储Student对下那个
        List<Student> list = new LinkedList<>();


        //2)添加元素
        list.add(new Student("a", 1, 10));
        list.add(new Student("b", 3, 20));
        list.add(new Student("e", 2, 30));
        list.add(new Student("s", 4, 40));
        list.add(new Student("y", 5, 50));
        list.add(new Student("w", 6, 60));
        System.out.println(list);

       //3)判断是否含有某个对象
        Student s1 =new Student("e", 2, 20);
        System.out.println(list.contains(s1));//false 是因为Student类 没有重写equals hashcode方法
        //重写了的话，就是判断数据的值是否相同
        list.remove(s1);
        Student s2 = new Student("e", 2, 20);
        System.out.println(s1.equals(s2));//true    如果没有重写，那么值会调用Object类中的equals方法，就只能判断 对象引用是否一致
            //如果重写了，就会去判断两个对象的数据是否相同
        //而重写之后的equals方法是 判断参数是否相同 ,如果没有重写，那么就是flase

        //4)在JDK8中，List集合增加了sort排序方法，可以对集合中的元素进行排序
        //sort 方法的形参是 Comparator 接口，在调用时，可以传递Comparator的匿名内部类对象

        list.sort(new Comparator<Student>() {
            //重写接口的抽象方法，在compare方法中，指定一个比较规则，
            //如果 o1比o2大，方法返回正数，就可以实现升序排序
            //如果02比O1大， 方法返回正数，就可以实现降序排序
            @Override
            public int compare(Student s1, Student s2) {
                return s1.age-s2.age;
            }

        });
        System.out.println(list);//升序

        //需求，根据成绩降序排序
        list.sort(new Comparator<Student>() {
            @Override
            public int compare(Student student, Student t1) {
                return t1.score-student.score;
            }
        });

        System.out.println(list);

        //根据学生的姓名升序
        list.sort(new Comparator<Student>() {
            @Override
            public int compare(Student student, Student t1) {
                return student.name.compareTo(t1.name);//调用了 String类的 compareTo方法 比较字符串大小
            }
        });
        System.out.println(list);

2.LinkedList
 *       底层双向链表
 *       先说单向链表，由若干的结点组成，每个节点除了存储数据外，还保存了下个结点的引用
 *          存放数据的叫数据域，存放下一个引用的叫指针域
 *            优点：插入/删除元素，与数组相比，不需要扩容，复制/移动元素，只需要修改指针域即可
 *            缺点：总是从第一个节点开始，一次向后访问，访问效率低
 *      双向链表：
 *             主要解决单向链表只能向后，不能向前访问的问题
 *             第一个元素称为头节点，最后 称 尾节点
 *
 *



 * 3.	LinkedList新增操作
 * Author pwj
 */
public class Test05 {
    public static void main(String[]args){

        //1)创建一个LinkedList集合
        LinkedList<String> linkedList =new LinkedList<>();
        linkedList.add("aa");
        linkedList.add("bb");
        linkedList.add("cc");
        linkedList.add("dd");
        linkedList.add("ee");
        System.out.println(linkedList);//[aa, bb, cc, dd, ee]
        //2)在头部 或尾部添加元素
        linkedList.addFirst("xx");
        System.out.println(linkedList);//[xx, aa, bb, cc, dd, ee]

        //3）尾部
        linkedList.addLast("zz");
        System.out.println(linkedList);//[xx, aa, bb, cc, dd, ee, zz]


        //4）返回头部/尾部元素
        System.out.println(linkedList.getFirst());//xx
        System.out.println(linkedList.getLast());//zz

        //5)删除 第一个和最后一个
        linkedList.removeFirst();
        linkedList.removeLast();
        System.out.println(linkedList);//[aa, bb, cc, dd, ee]

        //6)经常使用LinkedList模拟栈  栈 特点 后进先出

        linkedList.push("mm");//入栈  把 元素添加到列表的头部
        System.out.println(linkedList);//[mm, aa, bb, cc, dd, ee]
        linkedList.pop();//出栈，把列表的头部删除
        System.out.println(linkedList);//[aa, bb, cc, dd, ee]


        //7）经常使用LinkedList模拟列队，队列特点:先进先出，

        linkedList.offer("ss");//把元素添加到列表的尾部
        System.out.println(linkedList);//[aa, bb, cc, dd, ee, ss]
        linkedList.poll();//出队，把第一个元素删除
        System.out.println(linkedList);//[bb, cc, dd, ee, ss]
        linkedList.pop();
        System.out.println(linkedList);//作用和poll一样
				//[cc, dd, ee, ss]

  Set 集合 
  		特点：无序不可重复
  
  
  
        //创建set集合，存储String
        Set<String> set = new HashSet<>();

        //1)添加元素
        set.add("hello");
        set.add("h123");
        set.add("abc");
        set.add("lili");
        set.add("abc");

        //2)打印，set 不能存储重复的数据，存储顺序与添加顺序可能不一样
        System.out.println(set);//[abc, lili, h123, hello]   abc重复了

        System.out.println(set.size());//3
        System.out.println(set.contains("abc"));//true

        Iterator<String> iterator = set.iterator();
        while(iterator.hasNext()){
            String s = iterator.next();
            System.out.println(s);
        }

        //注意，Set存储的数据不重复，在删除时，直接remove
        //3）删除
        set.remove("abc");
        System.out.println(set);//[lili, h123, hello]

			 HashSet
 *  1)HashSet的底层是hashMap
 *  2）HashSet中添加元素就是把该元素作为键添加到底层的hashMap当中
 *         add会调用 底层map.put(e,PRESENT) 方法 ，相当于 下面代码中add
 *         的形参传给 e, 这个是键，然后值 是PRESENT
 *  3）HashSet就是HashMap键的集合
 *
 *TreeSet
 *  1）TreeSet实现了SortedSet接口，可以对集合中的元素进行排序，要求元素必须可以比较的
 *      在TreeSet构造方法中，指定comparator比较器
 *      如果没有构造方法中指定comparator比较器，要求元素的类实现comparable接口、
 *    注意：TreeSet是先选择Comparator ，在没有Comparator的情况下，再看类有没有实现Comparable
 *
 *
 * Author pwj
 */
public class Test03 {
    public static void main(String[]args){
        //1)定义TreeSet，存储String ，要求字符串降序排序

        TreeSet<String> treeSet = new TreeSet<>(new Comparator<String>() {
            @Override
            public int compare(String s, String t1) {
                return t1.compareTo(s);
            }
        });
        //通过构造方法定义 匿名内部类 指定一个comparator比较器
        treeSet.add("asd");
        treeSet.add("hello");
        treeSet.add("world");
        treeSet.add("lilili");
        treeSet.add("pwj");
        System.out.println(treeSet);//[world, pwj, lilili, hello, asd]

        //2)构造方法没有指定比较器
        //String 类实现了Comparable 接口,重写了 compareTo（）方法，如果第一个字符串大，返回正数
        TreeSet<String>  treeSet1 = new TreeSet<>();
        treeSet1.addAll(treeSet);//把TreeSet集合中所有的元素都添加到 TreeSet2中
        //addAll里面调用了 compareTo()方法，所以打印会把元素排序
        System.out.println(treeSet1);//已经是升序了[asd, hello, lilili, pwj, world]



 *  在TreeSet中存储自定义类型对象
 * Author pwj
 */
public class Test04 {
    public static void main(String[]args){
        //1）定义TreeSet存储Student  ，要求按成绩降序排序
        //在构造方法中指定comparator比较器
        TreeSet<Student> treeSet = new TreeSet<>(new Comparator<Student>() {
            @Override
            public int compare(Student student, Student t1) {
                return t1.score-student.score;
            }
        });
        treeSet.add(new Student("owj", 132, 123));
        treeSet.add(new Student("wj1", 132, 62));
        treeSet.add(new Student("ow2", 132, 23));
        treeSet.add(new Student("ow3", 132, 71));
        treeSet.add(new Student("ow4", 132, 12));
        System.out.println(treeSet);
        System.out.println("===========");
        Iterator<Student> iterator = treeSet.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }

        //2)判断
        //要注意 在TreeSet中 contains(o),remove(o).需要判断两个对象是否相同，根据comparator /comparable 比较结果是否为0 来决定的
        //因为前面定义了 用 成绩比较（可以理解为成绩比较器 升序 降序）， 所以如果 成绩相同，上面的两个方法都默认 参数对象和集合中的对象是一致
        //即 分数相同，如果删除，就删除集合中和指定分数相同的人，  判断是否包含这个人，就根据是否有这个分数 ，
        System.out.println(treeSet.contains(new Student("las", 123, 123)));//true

        //3）remove
        treeSet.remove(new Student("kao", 123, 123));
        System.out.println(treeSet);

        //4)在创建TreeSet，不在构造方法中指定comparator，要求元素的类实现comparable接口
        TreeSet<Student> treeSet1 = new TreeSet<>();
        treeSet1.addAll(treeSet);
        System.out.println(treeSet1); //以上代码执行 报错Exception in thread "main" java.lang.ClassCastException: class....
        //上面报错是因为 首先 treeSet1 在创建对象时没有指定构造器，然后，元素类没有实现Comparable 接口，
        //所以要在student类中 实现 ， 接着实现就要重写其抽象类的方法，  并且指定 排序的方法，compareTo

	
	Collection小结：
		集合存储引用类型数据，不能存储基本类型数据
		集合分为Colleciton和Map两大类
		Collection 时单个存储数据， Map是<键，值> 来存储数据
		
		Collection的基本操作：
			add(o),remove(o) contains(o)  size()
			itreator()   
			
		List://接口
		
			特点 
			 有序可以存储重复的数据
			存储数据和添加顺序一样，
			为每个元素指定一个索引值，增加了针对索引值的操作
			add(index,o),renmove(index),get(index),sex(index,o)
			
			JDK8新增了排序方法
			List.sort(new comparator)
			
			
	      1.ArrayList
	      	底层是数组  访问快，添加删除慢
	      	初始化容量是10
	      	扩容1.5倍
	   	  2.Vector
	      	底层是数组，与AraayList相比，它是线程安全
	      	初始化容量 10 
	      	扩容：2倍
	   		3.LinkedList 
	    		底层数据结构是双向链表，添加删除效率高，访问慢
	 				增加了针对第一个和最后元素的操作
	 				addFirst(o)/addLast(o);
	 				getFirst()/removeLast
	 				
	 				模拟栈  push(o)/pop   
	 				模拟队列 offer(o)/poll
	 		=====应用场景=========================================   		
	     如果想要存储可以重复的数据，选择List集合
	     如果以访问为主，选择ArrayList  
	     如果频繁进行添加删除，选择LinkedList
	     如果是在多线程环境中，选择 java.util.concurrent.CopyWriteArrayList
	     
	     ********注意*****************************
	     在List集合中，contains(o)，remove(o),这个操作需要判断对象元素是否相同，需要调用
	     元素的equals方法，如果集合中存储的是自己自定义类型对象，需要重写equals（）
	     
	     List是有序的 但是可以通过sort方法排序 而 Set中是通过Comparator
	     
	     
	 Set 
	  特点：		
	  		无序，存储顺序和添加顺序可能不一样
	  		不可以存储重复的数据
	  		
	  		
	 ---HashSet
	 			底层数据结构是HashMap
	 			向HashSet中添加元素，就是把该元素作为键添加到HashMap中
	 			HashSet就是HashMap键的集合
	 			
	 ----TreeSet
	 		TreeSet实现了SortedSet接口，可以根据元素自然排序，要求元素必须可比较
	 			 	1）在构造方法中指定Comparator比较器
	 			 	2）如果在构造方法中没有指定，元素的类需要实现comparable比较器
	 			 		对于TreeSet集合来说，先选择Comparator，在没有Comparator的情况下， 再选择Comparable
	 			 Tree底层是TreeMap
	 			 向TreeSet添加元素就是把元素作为键添加到TreeMap当中
	 			 TreeSet就是TreeMap键的集合
	     
	     
	 ====应用场景==================================================
	 	如果存储的数据不允许重复，选择set
	 	如果不需要对Set集合元素排序，就使用Hashset
	 	如果对Set元素排序，就使用TreeSet
	 	如果开发多线程程序，使用java.util.concurrent包中线程安全的集合类，
	 	如果不需要排序，使用 CopyOnWriteArraySet，如果需要排序，选择concurrentSkipList
	 
	 ******注意******************************************
	 HashSet中，判断元素是否相同，需要调用equals方法，如果存储的是自定义类型，需要重写equals方法
	 TreeSet集合判断是否相同元素，是根据comparator comparable比较 结果是否为0 ，如果比较结果返回0，
	 就认为是相同的元素 

		

        	
========================================================================================
      六 .泛型
				泛型就是把数据类型作为参数传递
				泛型的好处就是在编译的时候进行数据类型检查
				
				在Comparable/Comparator 接口通过泛型指定比较元素的数据类型
					class Student   implements Comparable<Student> {	}
					String  implements <String>
					
					
					
				在集合中，通过泛型指定存储元素的数据类型
				
				Collection<String> collection = new ArrayList<>();
				注意：定义集合时，在前面定义指定泛型才有效，后面赋值时不需要指定，系统可以推断出来
				如果是在JDK6中开发，则前后都需要指定
				
				List<Student> list = new ArrayList<Student>();
				
				如果在添加数据时，添加的数据与泛型指定的类型不兼容，语法错误
				
		（七）Collection工具类
				java.util包中提供了Collection工具类，在该工具类中定义了一组操作集合的方法
				   //集合里面只能放引用类型
        List<Integer> list = new ArrayList<>();
        //1)向集合中添加数据
        Collections.addAll(list, 75,123,82,2);
        //集合工具类
        System.out.println(list);
        
        
        
        
     
     Map  
     		Map集合是按<键，值>对 的形式存储 
     		void clear()  
     		 从该地图中删除所有的映射（可选操作）。  

				boolean containsKey(Object key) 
				如果此映射包含指定键的映射，则返回 true 。  

				boolean containsValue(Object value) 
				如果此地图将一个或多个键映射到指定的值，则返回 true 。  

				Set<Map.Entry<K,V>> entrySet() 
				返回此地图中包含的映射的Set视图。  

				boolean equals(Object o) 
				将指定的对象与此映射进行比较以获得相等性。  

				default void forEach(BiConsumer<? super K,? super V> action) 
				对此映射中的每个条目执行给定的操作，直到所有条目都被处理或操作引发异常。  

				V get(Object key) 
				返回到指定键所映射的值，或 null如果此映射包含该键的映射。  

				boolean isEmpty() 
				如果此地图不包含键值映射，则返回 true 。  

				Set<K> keySet() 
				返回此地图中包含的键的Set视图。  

	
				V put(K key, V value) 
				将指定的值与该映射中的指定键相关联（可选操作）。  

				void putAll(Map<? extends K,? extends V> m) 
				将指定地图的所有映射复制到此映射（可选操作）。  

				V remove(Object key) 
				如果存在（从可选的操作），从该地图中删除一个键的映射。  

				default boolean remove(Object key, Object value) 
				仅当指定的密钥当前映射到指定的值时删除该条目。  

					default V replace(K key, V value) 
				只有当目标映射到某个值时，才能替换指定键的条目。  

					default boolean replace(K key, V oldValue, V newValue) 
				仅当当前映射到指定的值时，才能替换指定键的条目。  

				int size() 
				返回此地图中键值映射的数量。  

				Collection<V> values() 
 				返回此地图中包含的值的Collection视图。 

     		
		Map操作
		  //1)定义一个map，保存员工的姓名和工资
        //通过泛型指定键值对 的数据类型，Map接口引用赋值实现类对象
        Map<String,Integer> map = new HashMap<>();

        //2)添加数据
        map.put("lili", 12132);
        map.put("lwangwu", 2232);
        map.put("zhal", 5122);
        map.put("pw", 150);
        map.put("cei", 1132);
        System.out.println(map);
        //{zhal=5122, lwangwu=2232, cei=1132, pw=150, lili=12132}

        //map的键是不允许重复
        map.put("lili", 20);
        //所以如果put添加的键已存在，会把新的value值替换掉 之前的value

        //3)判断
        System.out.println( map.containsKey("lili"));//true// 判断是否有这个键
        System.out.println( map.containsValue(12132));//判断是否有这个值  true

        System.out.println("=====4===");
        //4)删除
        map.remove("lili");
        System.out.println(map);

        //5)查看 键对应的值
        System.out.println(map.get("cei"));//1132
        //如果不存在 就返回null

        //6)遍历 键  和 value
        Set<String> set = map.keySet();
        System.out.println(set);//[zhal, lwangwu, cei, pw]

        Collection<Integer> values = map.values();
        System.out.println(values);//[5122, 2232, 1132, 150]

        Set<Map.Entry<String, Integer>> entries = map.entrySet();
        System.out.println(entries);//[zhal=5122, lwangwu=2232, cei=1132, pw=150]
//
        //关键是  前面的书写 是 Map.Entry< , >      因为是接口中的键  键用entry
        for(Map.Entry<String ,Integer> entry : entries) {
            //其实也相当于之前的  Employee empl  ： arraylist ）
            //就是逐个访问 arraylist集合中的 每一个employee元素
            System.out.println(entry.getKey() + "---->" + entry.getValue());
            //zhal---->5122
            //lwangwu---->2232
            //cei---->1132
            //pw---->150
        }

            System.out.println("=======7====");
            //7)修改
            map.replace("cei", 1200);
            System.out.println(map.get("cei"));//1200

            //8）删除
//            map.remove("cei", 800);//把 cei 800 删除 但是 map里面没有 这一对
//            System.out.println(map);//{zhal=5122, lwangwu=2232, cei=800, pw=150}
            map.remove("cei");
            System.out.println(map);//{zhal=5122, lwangwu=2232, cei=1200, lili=20}
            System.out.println(map.get("cei"));//null 没有的元素 得不到 返回null            


		1.HashMap工作原理
				1）HashMap底层数据结构是哈希表（散列表）
				2）哈希表就是另一种数组，其数组的每一个元素是单向链表，结合了数组和单向列表的优点
					单向列表里面分为4部分 ，1）hash值 2）key   3）value 4)next 下一个值的引用
						其实数组元素存储的是单向链表第一个节点的引用
				3)hashmap.put("song",25); 添加键值对
				
						3.1首先 根据键的哈希码，即“song”的hashCode（）的返回值 （即他的哈希码）
										通过hash函数计算得到哈希值
						3.2 根据hash值计算数组的下标i,
						
						3.3 访问数组元素table[i]，如果table{i}==null,系统会创建一个节点，存储到table[i]位置
								如果talbe[i]不是null，依次遍历单向链表的节点，如果有某个节点的key与当前的键相等，
								就使用新的value值，替换节点中原来的value值。
								如果链表中所有的key都不匹配，就会创建一个节点，插入到链表的尾部
						
						//创建HashMap集合  --》哈希表   数组  16个长度
        HashMap<String,Integer> hashMap = new HashMap<>();
        //默认16长度（不严谨）

        //2）添加键值对
        hashMap.put("lis",25);

        //3）再添加一对
        hashMap.put("wang",20);
        //根据"wang" 调用hashCode 返回这个键的哈希码，根据哈希码计算得到哈希值，然后通过哈希值计算数组的下标i
        //不同的键经过hash函数得到的值可能是相同的
        //访问table[i]，如果不为null，遍历table[i]单向链表的每一个节点，如果所有节点的key都不匹配，创建一个新的节点，插入到链表的尾部，


        //4)哈希冲突
        //不同的键 ，经过哈希函数，得到同样的哈希值，计算数组时，下标就相同，这就是哈希冲突，hashMap如何解决？
        //           就是采用链表法   单向链表
        //JDK8性能的提升，有两个方面，1)在JDK8前，把节点插入到链表的头部，在JDK8中，是把新的节点插入到链表的尾部，
        //                         2）当单向链表中的节点数量，超过8个时，系统会把单向链表的结构改为红黑树结构


				HashMap的get工作原理
					3）根据键的哈希码经过哈希函数得出哈希值，根据哈希值计算出数组的下标，
					4）如果访问数组[i],如果 数组元素table[i]为null，直接返回null
							如果不为null，遍历table[i]单向链表的每一个节点，如果有某个节点的key与当前的
							键 相等，就把节点的value值返回，如果链表所有的节点的key都不匹配，就返回null
							这就以为着 get 返回null，不一定因为没有元素，而可能是没有匹配
							
							
	2.HashTable
			HashTable与HashMap的异同点
				1）底层数据结构都是哈希表，但是HashTable是线程安全
				2）HashMap初始化容量：16 ，HashTble初始化容量：11
					默认加载因子是0.75  
				3）HashMap扩容是按两倍大小扩容，HashTable 是 按2倍 +1 扩容
				4）都指定初始化容量，HashMap会把初始化容量调整为2的幂次方
					HashMap 把17-31之间的初始化容量调整为32，把33-63之间的初始化容量调整为64，为了快速计算数组的下标
					HashTable 不调整  给的是多大容量，就是多大
					
					HashMap 的键值对可以为 null
					HashTable 的键值对不可以为 null
		
		
		
	3. Properties  
		properties 继承了 HashTable 
				键与值 都是String字符串
				经常用于设置/读取系统属性
					setProperties(属性名，属性值)
					getProperties(属性名)
					
		Properties = System.getProperties();//返回系统的属性
		  //创建properties 对象
        Properties properties = new Properties() ;
        //获得properties系统属性

        properties = System.getProperties();
//        System.out.println(properties);
        Set<Map.Entry<Object, Object>> entries = properties.entrySet();
        for(Map.Entry<Object,Object> p : entries){
            System.out.println(p);
        }

        Set<String> set = properties.stringPropertyNames();
        for(String name : set){
            System.out.println(name+"----->"+properties.getProperty(name));
        }

        properties.setProperty("abc", "feifei");//另外设置的
        System.out.println(properties.getProperty("abc"));
    }


 使用properties读取 配置文件的信息
 *      1)经常把程序的属性保存到配置文件中
 *      2）一般情况下，在src目录中创建一个resources资源包，在该包中添加配置文件，配置文件的后缀名：.properties
 * Author pwj
 */
public class Test01 {
    public static void main(String[]args) throws IOException {
        //1)通过properties读取配置文件
        Properties properties = new Properties();
        //2）建立字节流 字符流
//        InputStream in = Test01.class.getClassLoader().getResourceAsStream("resources/config.properties");
        //还可以使用以下的方法
        InputStream in = Thread.currentThread().getContextClassLoader().getResourceAsStream("resources/config.properties");
        properties.load(in);//如果产生空指针异常 就检查配置文件的路径是否正确
        System.out.println(properties.getProperty("username"));//两种获取值的方式都可以采用
        System.out.println(properties.get("password"));//lili  666

        //3）还可以使用ResourcesBundel读取配置文件
        ResourceBundle bundle = ResourceBundle.getBundle("resources/config");//后面不需要配置文件的扩展名
        System.out.println(bundle.getString("username"));
        System.out.println(bundle.getString("password"));

		
		
		4.TreeMap
**
 * TreeMap
 *      1)实现了 SortedMap接口，可以根据键自然排序，要求键可比较
 *             1.可以在构造方法中指定comparator比较器
 *             2.如果构造方法中没有comparator比较器，要求元素的类实现comparable接口
 				TreeMap的键根据红黑树原理排序，红黑树一种自平衡二叉树
 *
 *        注意：TreeMap是先选择Comparator，在没有comparator的情况下， 再选择Comparable，
 *        对于程序员来说，如何选择?
 *          一般情况下，让键实现Comparable 接口， 定义一个默认的比较规则，可以通过Comparator可以定义很多不同的比较规则
 *  2）在Map中，它的键一般是String字符串，极少使用自定义类型作为键 
 * Author pwj
 */
public class Test01 {
    public static void main(String[]args){

        //创建TreeMap,保存员工姓名与工资，根据姓名降序排序 ，
        TreeMap<String,Integer> treeMap = new TreeMap<>(new Comparator<String>() {
            @Override
            public int compare(String s, String t1) {
                return t1.compareTo(s);
            }
        });

        treeMap.put("lis", 1200);
        treeMap.put("lisi", 400);
        treeMap.put("wangwu", 5200);
        treeMap.put("fei", 11500);
        treeMap.put("zhao1", 600);
//实现降序排序
        Set<Map.Entry<String, Integer>> entries = treeMap.entrySet();
        for(Map.Entry<String,Integer> entry : entries){
            System.out.println(entry);
            //zhao1=600
            //wangwu=5200
            //lisi=400
            //lis=1200
            //fei=11500
        }

            //2）如果TreeMap构造方法中 没有指定comparator，元素的类必须实现comparable
        TreeMap<Employee,Integer> treeMap1 = new TreeMap<>();

        treeMap1.put(new Employee("a"), 123);
        treeMap1.put(new Employee("b"), 123);
        treeMap1.put(new Employee("cs"), 123);
        treeMap1.put(new Employee("s2321"), 123);
        treeMap1.put(new Employee("gad"), 123);
        treeMap1.put(new Employee("we"), 123);
        treeMap1.put(new Employee("hf"), 123);

        Set<Map.Entry<Employee, Integer>> entries1 = treeMap1.entrySet();
        for(Map.Entry<Employee,Integer> entry : entries1){
            System.out.println(entry);
        }


		TreeMap的键根据红黑树原理排序  是一种自平衡二叉树
		
		二叉树：有一个根称为节点，其他的每个节点最多只有两个节点，左边叫左子树，右边叫右子树
		左子树的节点小于根，右子树的节点都大于根
		
		遍历二叉树有3种方法：
				1）先根序遍历
					先访问根，再遍历左子树，再遍历右子树
				2)后根序遍历
					先遍历左子树，再遍历右子树，最后访问根
				3）中序遍历
				先遍历左子树，然后访问根，再遍历右子树
				
				
	Map小结
			Map是按<键，值>对的形式存储数据
			基本操作：
					put<k,v>     size()   containsKey(k)  containsValue(v)  get(k)
					keySet()		values()   entrySet()   
					remove<k,v>   remove(k)     
					replace<k,v>    
					
		----HashMap
				底层是哈希表
				初始化容量16
				扩容2倍大小扩容
				可以指定初始化容量，系统会调整为2的幂次方
				
				
		----HashTeble 
		底层也是哈希表，初始化容量为11，扩容2倍+1 ，可以执行初始化容量，系统不会调整
					而且是线程安全的，HashMap不是线程安全的，键和值都不能为null
					
					
					
	----properties
					
				继承了HashTbale 
				特点 键和值都是String 字符串
				经常用于设置/读取系统属性
				setProperties(属性名，数性质)
				getProperties（属性名
		
			System.getProperties( ), 可以获得系统的属性
			
			
-----TreeMap 
				实现了 sortedMap接口，可以根据自然排序，要求键必须是可比较的
				 	1）可以在构造方法中指定comparator 
				 	2）没有在构造方法中指定，元素的键必须实现comparable接口	
			对于程序员来说，可以在键中实现comparable接口 ，定义一个默认的比较规则，
			再构造方法中通过comparator定义其他的比较规则
			TreeMap中的键，是根据红黑树进行排序的
			
=========应用场景==========================================================
	存储<键，值>对选择Map
	如果不需要根据键排序，就选择HashMap
	如果需要根据键排序，选择TreeMap
	注意：TreeMap 只能根据键排序，不能根据值排序
	如果在多线程环境中，如果不需要键排序，就选择ConcurrentHashMap，如果需要键排序，
	选择ConcurrentSkipListMap
	java.util.concurrent.ConcurrentHashMap 采用了分段锁协议，默认分为16段锁，可以提高Map的并发性
	
	******注意**************************************************************
	HashMap中的键需要重写 equals（）/hashCode（）
	
	
	
	
	
	3.9 Lambda表达式
			Lambda表达式时JDK8新增的一个突出的特性
				
	
	


	4、 异常
	
		4.1异常概述
				1）空指针异常  NullPointerException
				2）数组下标越界异常  ArrayIndexOutOf
				3）算术异常  
				4）类型转换异常
		
				5）不支持的编码异常
				6）日期转换异常//  ParseException
				7）IO异常  IOException
				
		异常是什么？
				异常就是程序运行过程中遇到的不正常的现象
			java把这些常见的现象进行了抽象，就形成了异常类
			
			
	异常处理
		在定义方法时，通过thorws声明抛出一个异常类，而该异常类没有继承RuntimeException，则是受检异常
		，调用方法时，就要对该异常进行预处理
		
		
			处理：	
				1）throws 抛出处理
				2）try/catch 捕获处理				
				
		
		如何选择异常处理的方式？
				1）一般情况下，如果调用的方法有受检异常需要预处理，就选择捕获处理
				2）如果能确保调用方法肯定没有异常产生，可以选择 throws 抛出处理，
					 比如， "".getbytes("GBK"),因为SUN公司提供的这个getbytes方法，抛出了异常，该异常不是runtime的异常
					 所以，在调用这个方法，上面就是把字符串的内容，转换成字节数组，调用这个编译时的异常，就要对其进行预处理，防止出现异常嘛
					 但是不是说一定出现异常，所以 如果肯定没有自己写的代码没错，就是有GBK这种编码格式，那么，程序还是会正常运行的
					 这样，就没必要通过捕获异常来处理了，直接throws 交给调用者来处理，调用者 最后会给main，而mina方法，就会交给jvm处理
					 ，jvm就会中止程序，并且打印异常信息，但这样没有提高代码的健壮性，但是你都确保了正确，就不需要什么健壮性了对吧
					 就好像买保险，你都确认自己不会受伤之类的，还买啥保险
					而选择了 try catch 来捕获，一般受检异	常都放在try里面，按 ctrl + alt + t ，  然后 catch 就会自动对应生成，
					有多少个受检异常，就会有多少个catch，这样提高健壮性的原因是：首先，如果有多个受检异常，而且第一个受检异常确认运行时不会报错的话
					那么 自然会自然相应的代码，程序不会跳到 catch ，如果下一个异常，也就是说下一行代码，调用了某个sun公司提供的继承了不是runTime的异常，
					也就时受检异常，并且 自己还写错了， 比如 new SimpleDateFormat() 里面需要定义一个转换格式，再通过调用 .parse（）里面需要提供一个具体日期的实参，
					才可以用Date 接收， 如果 写错了，或者写不对，那么 异常就产生了，意味着 可能性的事件发生了，那么就会跳到对应的 catch 中
					就会执行 print。。输出异常信息的语句  并且！ 不会中断，但是呢 try里面的 这行出问题的代码，后面的代码都不会执行了，但是，其他的代码还是会执行，就是
					try catch 后面的代码会照样执行  只是try 里面所有的受检对象 哪个受检出问题，后面的也不会执行 了
					自己理解的受检异常： 就用 getbytes（）来说，按道理 ，如果括号里面提供的编码格式给定了，程序员不能自己瞎写对吧，
					那么无论选中哪个格式，都没问题，都是对的，那么就不存在错误的情况，但是 括号里面填的不是一种给定的模式，而时，
					自己用字符串的形式去填入，一旦填入的，和Sun公司里面有的不符合，那么不就是一种异常了嘛？所以才会throws 抛出了异常，就是预防出现问题
					所以我们在调用的时候，就要try 或者throws 一下， 否则就会错啦~
				如果在定义方法时，如果方法体中受检异常，可以选择捕获，也可以抛出 
				如果在定义方式时，方法体通过throw 抛出了一个受检异常对象，所在方法通过trows声明该异常
															这个throw没有s结尾 
															
															
			如果自定义的异常类，没有继承RuntimeException，就是受检异常，调用异常类的方法体在声明的时候，就要进行预处理
												如果继承了RuntimeException，就是运行时的异常，含有调用异常的方体就不需要声明异常，直接使用即可
															
										
			对于有继承关系的异常 ，在对应的 catch 语句中，先后顺序是有规定的，父类异常必须放到最后，而子类异常而可以选择写，或者，不写
			不写就用父类异常来表示， 所以说 异常可以相同，可以更小
															
		 finally 子句
 *      1）final finalize finally 的区别
 		第一个 关键字，表示最终。不可改变
 		第二个时 垃圾回收器会用来的
 *
 * Author pwj
 */
public class Test05 {
    public static void main(String[]args){



        try {
            byte[] gbks = "hello昂是".getBytes("GBK");
            System.out.println("===");
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }finally {
            System.out.println("在异常处理时，可以有finally子句，这是不必须的，不管是否有异常，总是会执行" +
                    "一般在这里释放系统资源");
            //讲IO的时候
        }
        int num = sm(10);
        System.out.println(num);//10
        System.out.println();

        System.out.println("===");
    }
    public static int sm(int xx){
        try{
            return xx;
            /*
            程序执行到这里时， 并没有立即执行 return  而把xx变量的值保存起来了
            执行finally子句，再执行return ，返回的是当前保存xx的值
            不要再finally 子句中使用return
             */
        }finally {
            xx =xx+10;
//            return xx;//如果有这条语句，那么输出结果是20
        }
    }
}

			try中有返回，那么就会把 xx 值用一个局部变量来存储xx的值，如果finally 的语句没有return，那么，这个保存的值
			一定不会变，就是xx得值 就好比如  用a = xx  接收了 xx得值， return a  而不是
			但是也不影响 finally 语句中，对xx值的改变，就是 xx 可以+ - 。。会改变xx的字面值，但是，不能改变
			try 中返回的值， 而如果，finally 有return，那么执行到return 该返回什么就返回多少，也不能回去try中的值了
			


============异常在开发中的应用============================

	自定义异常
			1）定义一个异常类，异常类以Exception结尾
			如果异常类继承了RuntimeExecption，就是一个运行时异常，
			如果异常类继承了Exception，就是受检异常
			
			一般只提供两个构造方法，一个无参，一个有String参数的构造方法
			
			在需要的位置通过throw抛出一个异常对象
			
			如果抛出的异常对象时受检异常对象，所在的方法需要通过throws声明该异常
			
			
			方法覆盖中的异常处理
					4.1方法签名必须相同
					4.2返回值类型可以相同，也可以是子类型
					4.3访问权限可以相同，也可以更大
					4.4抛出的异常可以相同，也可以更小
					
					
					
					
					
	五.反射
			5.1 反射概念
				反射就是根据字节码文件，反射类的信息，类成员的信息，根据字节码文件，创建
				对象，访问字段，调用方法的技术
					有了字节码文件，就可以通过反射技术，了解到类中有哪些内容，类似于反编译
					创建对象，调用方法
				反射依赖于Class对象
				把小狗抽象为Dog类，把人抽象为Person类，把Dog、person .... 等所有类抽象为
				Class类，Class类，描述的是所有类共有的特征和行为
					反射第一步，创建Class对象，可以简单理解为获得类的字节码文件
						有以下方式：
				1)每个类都有calss属性， Dog.class Person.class
				2）每个对象都有getClass（）方法，从Object继承来的
				3）Class.forName（完整类名）
		5.2 反射类的信息
			//1）创建Class对象
					Class class01 = String.class;
				
				
			//2)
					// 返回类的修饰符
			
			int mod = class01.getModifiers()
			String modifier = Modifier.toString(mod);
			
					//类名
			class01,getName();
			class.getSimpleName();
			
					//父类
			class01.getSuperclass();
			
				//接口
			class.getInterfaces();
			Class class01 = Integer.class;
        Class class02 = String.class;

        //2)反射类信息
        //2.1类的信息，

        //  修饰符 modifier
        int modifiers = class01.getModifiers();//这个方法的返回值 是 int 整数类型
//        System.out.println(modifiers);//17
        String m1 = Modifier.toString(modifiers);//使用 Modifier类的toString（）方法，把整数转换为字符串
        System.out.print(m1);//public final  修饰符


        //  类名，
        System.out.print(" class ");
        String name = class01.getName();
//        System.out.print(name);//java.lang.Integer //完整类名
        name = class01.getSimpleName();//简易类名
        System.out.print(name);//Integer

        //  父类
        System.out.print(" extends ");
        Class superclass = class01.getSuperclass();//方法返回值是 Class对象
        System.out.print(superclass.getSimpleName());//Number


        //  接口
        Class[] interfaces = class01.getInterfaces();//方法返回值是 一个数组，一个类可能实现多个接口
        if(interfaces.length>0){
            System.out.print(" implements ");
        }
        //如果类没有实现接口，数组长度为0
        for(int i = 0 ; i<interfaces.length;i++){
            System.out.print(interfaces[i].getSimpleName());
            if(i<interfaces.length-1){
                System.out.print(",");
            }
        }
        //Comparable

        Class[] interfaces1 = class02.getInterfaces();
        for(int i = 0 ; i<interfaces.length;i++){
            System.out.print(interfaces[i].getSimpleName());
        }
        //String 类  实现了3个接口   即 类是这个接口的实现     接口赋值实现类
//        Serializable
//        Comparable
//        CharSequence

			
	5.3访问字段 
	   //1）创建Class对象
        Class<?> claxx = MyClass.class;

        //2)实例变量是属于某个具体对象的，应该先创建对象，再访问字段
        Object o = claxx.newInstance();

        //3)反射公共字段xx
        Field xx = claxx.getField("xx");		
        xx.set(o, 120);//通过字段的set方法设置对象的值，因为可能有不同的对象，所以。。
       //相当于： o.setXX(120)  不过这里是 反射技术 ，是通过 claxx
        System.out.println(o);//MyClass{xx=120, yy=0, zz=0}

        //4）通过构造方法创建一个实例
        Constructor<?> constructor = claxx.getConstructor();
        Object o1 = constructor.newInstance();
        System.out.println(o1);//MyClass{xx=0, yy=0, zz=0}

        Constructor<?> constructor1 = claxx.getConstructor(int.class, int.class, int.class);
        Object o2 = constructor1.newInstance(11, 12, 13);
        System.out.println(o2);//MyClass{xx=11, yy=12, zz=13}
        //需求返回o2对象xx的值
        System.out.println(xx.get(o2));//11

        //6）反射私有字段ZZ
        Field zz = claxx.getDeclaredField("zz");
//        System.out.println(zz.get(o2));//报错 IllegalAccessException: 没有访问权限
        //7）设置字段的可访问性
        zz.setAccessible(true);
        zz.set(o2, 12);
        System.out.println(zz.get(o2));//12
        //如果没有先设置访问权限，就无法设置 而且运行报错
        System.out.println(o2);//MyClass{xx=11, yy=12, zz=12}

        //8）反射静态字段
        Field ss = claxx.getDeclaredField("ss");//类中的静态没有用public 修饰 所以要用 Declare..
        ss.set(o2, 10);
        System.out.println(ss.get(o2));//10
	5.4返回字段
		    //1)创建class对象
        Class class01 = Integer.class;
        //2)Field
//        class01.getFields();//返回所有公共的字段
//        class01.getField(字段名)//返回指定字段名的公共字段
//        class01.getDeclaredFields();//返回所有的字段
//        class01.getDeclaredField(字段名)//返回指定名称的字段
        StringBuilder sb  = new StringBuilder();//
        Field[] declaredFields = class01.getDeclaredFields();
        for(Field field : declaredFields){
            //字段修饰符
            int modifiers = field.getModifiers();
            sb.append(Modifier.toString(modifiers)+" ");

            //字段类型
            sb.append(field.getType().getSimpleName()+" ");

            //字段名
            sb.append(field.getName()+"\n");
        }
        System.out.println(sb);
		
	5.4反射方法
	
		Method [] allMethod = claxx.getMethod(); //所有公共方法
		Method method = claxx.getMethod(方法名，形参列表);
		method.getModifiers();//返回方法修饰符
		method.getReturnType（）；//方法返回值类型
		method.getName();  方法命
		method.getParameterTypes（）形参类型列表
		
		Constructor 构造方法   
		claxx.getConstructors（）返回所有公共构造方法 
		claxx.getConstructors(构造方法形参列表);

//1)
        Class<?> class01 = String.class;

        //2)Method
//        class01.getMethods();//反射所有的   公共方法
//        class01.getDeclaredMethods();//反射所有 方法	
//        class01.getMethod(方法名,方法的形参列表);//返回指定方法签名的公共方法

        StringBuilder stringBuilder = new StringBuilder();
        Method[] declaredMethods = class01.getDeclaredMethods();
        for(Method method : declaredMethods){
//            System.out.println(method);
            //byte[] java.lang.String.value()
            //public boolean java.lang.String.equals(java.lang.Object)
            //public int java.lang.String.length()
            //public java.lang.String java.lang.String.toString()
            //public int java.lang.String.hashCode()
            // 等等。。。。。

            //方法的修饰符
            String s = Modifier.toString(method.getModifiers());
            //通过Modifier 修饰类 调用toString  实参是 method类调用的getModifier，返回的是method对应修饰符的int ，实参就是int 然后就会对应了 Modifier当中对应的String
            stringBuilder.append(s+" ");

            //方法的返回值类型
            Class<?> returnType = method.getReturnType();
            String simpleName = returnType.getSimpleName();
            stringBuilder.append(simpleName+" ");
            //方法的方法命
            String name = method.getName();
            stringBuilder.append(name+" " );
            //参数
            stringBuilder.append("(");
            Class<?>[] parameterTypes = method.getParameterTypes();
            for(int i = 0 ; i<parameterTypes.length;i++){
                stringBuilder.append(parameterTypes[i].getSimpleName());
                //参数之间使用逗号分隔
                if(i<parameterTypes.length-1){
                    stringBuilder.append(",");
                }
            }
            stringBuilder.append(")\n");
        }
        System.out.println(stringBuilder);

	
	
	5.5创建对象
	
    //通过反射技术创建MyClass类的对象(实例--》instance

    //1）创建
    Class<?> claxx = MyClass.class;//字节码文件

    //2)通过class1对象来直接创建MyClass实例
        //class对象有newInstance方法，可以创建实例，会默认调用类的无参构造
        Object o = claxx.newInstance();//默认调用MyClass的无参构造
        //抛出了异常   非法访问，实例化异常
//如果没有无参构造，就会报错

        //运行输出了：MyClass的无参构造
        System.out.println(o);
        //MyClass{xx=0, yy=0, zz=0}


       //3）通过构造方法创建实例(有参数的）
        //先反射构造方法，通过构造方法创建实例，
        Constructor<?> constructor = claxx.getConstructor(int.class, int.class, int.class);//调用的方法形参是 class 类型，所以是 int.class 即 int 的class字节码
        Object o1 = constructor.newInstance(10, 20, 30);
        System.out.println(o1);
        //MyClass{xx=10, yy=20, zz=30}

        //反射无参构造创建实例
        Constructor<?> constructor1 = claxx.getConstructor();
        Object o2 = constructor1.newInstance();
        System.out.println(o2);//MyClass{xx=0, yy=0, zz=0}
//        Constructor<?>[] constructors = claxx.getConstructors();//这个构造器是不对的 因为后面有s

		
		
		
	
		    //1)
        Class<?> class01 = String.class;

        //2)Method
//        class01.getMethods();//反射所有的   公共方法
//        class01.getDeclaredMethods();//反射所有 方法
//        class01.getMethod(方法名,方法的形参列表);//返回指定方法签名的公共方法

        StringBuilder stringBuilder = new StringBuilder();
        Method[] declaredMethods = class01.getDeclaredMethods();
        for(Method method : declaredMethods){
//            System.out.println(method);
            //byte[] java.lang.String.value()
            //public boolean java.lang.String.equals(java.lang.Object)
            //public int java.lang.String.length()
            //public java.lang.String java.lang.String.toString()
            //public int java.lang.String.hashCode()
            // 等等。。。。。

            //方法的修饰符
            String s = Modifier.toString(method.getModifiers());
            //通过Modifier 修饰类 调用toString  实参是 method类调用的getModifier，返回的是method对应修饰符的int ，实参就是int 然后就会对应了 Modifier当中对应的String
            stringBuilder.append(s+" ");

            //方法的返回值类型
            Class<?> returnType = method.getReturnType();
            String simpleName = returnType.getSimpleName();
            stringBuilder.append(simpleName+" ");
            //方法的方法命
            String name = method.getName();
            stringBuilder.append(name+" " );
            //参数
            stringBuilder.append("(");
            Class<?>[] parameterTypes = method.getParameterTypes();
            for(int i = 0 ; i<parameterTypes.length;i++){
                stringBuilder.append(parameterTypes[i].getSimpleName());x
                //参数之间使用逗号分隔
                if(i<parameterTypes.length-1){
                    stringBuilder.append(",");
                }
            }
            stringBuilder.append(")\n");
        }
        System.out.println(stringBuilder);

					
		
					
	六、注解
		
		注解：注解就是一种特殊标记，可以在程序中加入的额外信息
		可以根据这些注解进行更进一步的而操作

注意：注解不影响程序执行的
		
		在java.lang包中定义了一些注解  
			Deprecated:已过时
			Override 注解： 告诉编译器进行方法覆盖语法检查
			FunctionalInterface  表示函数接口，为Lambda表达式准备的 
			

					

				
				
				
				
				


